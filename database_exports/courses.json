[
  {
    "_id": "68f7ba8b531b6a649806df0d",
    "title": "Python for Beginners",
    "description": "Master the basics of Python programming — from variables to object-oriented programming. Learn with theory, quizzes, and coding challenges.",
    "slug": "python-for-beginners",
    "xp_reward": 500,
    "created_at": "2025-10-21T16:53:31.574000",
    "updated_at": "2025-10-21T16:53:31.574000",
    "modules": [
      {
        "module_id": "8ef29f9f-39e3-4777-b8a4-89e347d104a3",
        "title": "Variables, Data Types, and Operators",
        "order": 1,
        "topics": [
          {
            "topic_id": "e70ebf9c-3bfd-4a24-94c8-6868da443429",
            "title": "Understanding Variables",
            "content": "Learn what variables are and how to assign values in Python.",
            "xp_reward": 40,
            "cards": [
              {
                "card_id": "6ddc9d3c-9ab7-44c6-ab64-bf7ad833d987",
                "type": "theory",
                "content": "Variables are used to store data values. In Python, you can assign values using the '=' operator.",
                "xp_reward": 10,
                "explanation": "Python does not require variable declaration. You can assign any type of data to a variable."
              },
              {
                "card_id": "4a05bf86-2690-41b6-b926-dcab57d4f7d5",
                "type": "mcq",
                "content": "Which of the following correctly assigns a value to a variable in Python?",
                "xp_reward": 10,
                "explanation": "Python uses '=' for assignment, not ':=' or '->'.",
                "choices": [
                  "x = 10",
                  "x := 10",
                  "x -> 10",
                  "let x = 10"
                ],
                "correct_choice_index": 0
              },
              {
                "card_id": "b5daed24-b482-4b62-85c5-130f710a538b",
                "type": "code",
                "content": "Create a variable 'age' and assign your age to it, then print it.",
                "xp_reward": 20,
                "explanation": "Variables store data that can be reused and modified later.",
                "starter_code": "# Create a variable called 'age' and print it\n\n",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "21"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          },
          {
            "topic_id": "3ec9d666-bbc9-4fc8-b09c-58319b0d69dd",
            "title": "Data Types and Operators",
            "content": "Learn about Python's built-in data types and operators for arithmetic and comparison.",
            "xp_reward": 60,
            "cards": [
              {
                "card_id": "2f576460-bd39-4afb-bea8-ec1ee58e6aca",
                "type": "theory",
                "content": "Common Python data types include int, float, str, bool, and complex.",
                "xp_reward": 10,
                "explanation": "Python automatically determines the data type based on the assigned value."
              },
              {
                "card_id": "9a44a054-616a-4f81-aa1a-c0ce1a6febc7",
                "type": "mcq",
                "content": "What is the result of the expression `5 + 3 * 2`?",
                "xp_reward": 10,
                "explanation": "Python follows operator precedence: multiplication before addition.",
                "choices": [
                  "16",
                  "11",
                  "13",
                  "10"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "a0d23c7d-2db3-4b79-bcbe-a245e476e1ca",
                "type": "code",
                "content": "Write a Python program that takes two numbers and prints their sum and product.",
                "xp_reward": 20,
                "explanation": "Use arithmetic operators '+' and '*'.",
                "starter_code": "# Input two numbers and print sum and product\nnum1 = int(input())\nnum2 = int(input())\n# Your code here\n",
                "test_cases": [
                  {
                    "input": "5\n3",
                    "expected_output": "8\n15"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "1fc99da6-a730-4675-8321-925b9ebcd551",
                "type": "fill_blank",
                "content": "In Python, the _____ operator is used for exponentiation.",
                "xp_reward": 20,
                "explanation": "Example: 2 ** 3 equals 8."
              }
            ]
          }
        ]
      },
      {
        "module_id": "084f4a06-f601-4689-8594-8e702ddd5316",
        "title": "Lists, Dictionaries, and Tuples",
        "order": 2,
        "topics": [
          {
            "topic_id": "0773bf99-c67b-43ce-b5f6-8b5ac41e7351",
            "title": "Lists and Their Operations",
            "content": "Learn how to store multiple items in a single variable using lists.",
            "xp_reward": 50,
            "cards": [
              {
                "card_id": "4ce92747-7b3a-43cb-85c7-bd1c83558e7a",
                "type": "theory",
                "content": "Lists are ordered, mutable collections written with square brackets [].",
                "xp_reward": 10,
                "explanation": "You can modify, append, or remove elements in a list."
              },
              {
                "card_id": "4cfdc14b-9330-4b68-b374-f44e93ad9709",
                "type": "mcq",
                "content": "What is the correct way to access the first element of a list `fruits = ['apple', 'banana', 'cherry']`?",
                "xp_reward": 10,
                "explanation": "Python lists are zero-indexed.",
                "choices": [
                  "fruits[0]",
                  "fruits[1]",
                  "fruits.first()",
                  "fruits.get(0)"
                ],
                "correct_choice_index": 0
              },
              {
                "card_id": "d5b807b4-19ad-4295-bf70-5f86984a250a",
                "type": "code",
                "content": "Create a list of three fruits and print the second fruit.",
                "xp_reward": 30,
                "explanation": "Use indexing to access list elements.",
                "starter_code": "# Your code here\nfruits = ['apple', 'banana', 'cherry']\n",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "banana"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          },
          {
            "topic_id": "6996424a-7721-458d-abd7-f6364113c6e0",
            "title": "Dictionaries and Tuples",
            "content": "Understand how to store data in key-value pairs and immutable sequences.",
            "xp_reward": 50,
            "cards": [
              {
                "card_id": "855cf045-7a66-40b9-b02c-4dcc33f45fe1",
                "type": "theory",
                "content": "Dictionaries use keys and values. Tuples are immutable sequences enclosed in parentheses ().",
                "xp_reward": 10,
                "explanation": "Dictionaries are great for structured data like mappings."
              },
              {
                "card_id": "02752460-af39-4bbb-9e64-d8ab9cccdfef",
                "type": "code",
                "content": "Create a dictionary with keys 'name' and 'age', print both values.",
                "xp_reward": 20,
                "explanation": "Access values using keys like data['name'].",
                "starter_code": "# Your code here\ndata = {'name': 'John', 'age': 25}\n",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "John\n25"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "496494b6-2a02-4dff-9e37-04f65b6dd08a",
                "type": "fill_blank",
                "content": "Tuples are _____, meaning their values cannot be changed after creation.",
                "xp_reward": 20,
                "explanation": "Tuples are faster and use less memory than lists."
              }
            ]
          }
        ]
      },
      {
        "module_id": "cd003e04-ce91-4c1f-80e5-2670b46b4fbe",
        "title": "Functions and Control Flow",
        "order": 3,
        "topics": [
          {
            "topic_id": "4fb1e5d3-ad34-4624-ba4a-5c6e51eee7df",
            "title": "If/Else and Loops",
            "content": "Learn to control program flow with conditionals and loops.",
            "xp_reward": 60,
            "cards": [
              {
                "card_id": "262182a6-5a0a-461d-bf6e-e6236c7cc650",
                "type": "theory",
                "content": "If/Else statements let you execute code based on conditions. Loops (for, while) repeat actions.",
                "xp_reward": 10,
                "explanation": "Use indentation to define code blocks in Python."
              },
              {
                "card_id": "9b32acc6-da4e-42d4-a985-d7b686142ffc",
                "type": "mcq",
                "content": "Which loop is best for iterating over a list in Python?",
                "xp_reward": 10,
                "explanation": "The 'for' loop is ideal for iterating over sequences.",
                "choices": [
                  "for",
                  "while",
                  "do-while",
                  "foreach"
                ],
                "correct_choice_index": 0
              },
              {
                "card_id": "7ae00731-14a9-4333-84c8-70df70570fdd",
                "type": "code",
                "content": "Write a loop to print numbers 1 to 5, each on a new line.",
                "xp_reward": 40,
                "explanation": "Use a range-based for loop.",
                "starter_code": "# Your code here\n",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "1\n2\n3\n4\n5"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          },
          {
            "topic_id": "f281c5fc-a872-4d34-97fb-33bd67161a49",
            "title": "Functions in Python",
            "content": "Functions help you reuse code blocks efficiently.",
            "xp_reward": 60,
            "cards": [
              {
                "card_id": "0d77f522-ef47-452b-8ae0-f80de71abad5",
                "type": "theory",
                "content": "Functions are defined using the `def` keyword followed by a name and parentheses.",
                "xp_reward": 10,
                "explanation": "Functions promote code reusability."
              },
              {
                "card_id": "d18d3ba3-b4a8-4156-abf5-bd2a2418beff",
                "type": "code",
                "content": "Define a function `add(a, b)` that returns their sum.",
                "xp_reward": 50,
                "explanation": "Return the sum using the return keyword.",
                "starter_code": "def add(a, b):\n    # Your code here\n\nresult = add(5, 3)\nprint(result)",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "8"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          }
        ]
      },
      {
        "module_id": "8faafa3d-b51f-45fa-92b9-8a675a25c7f3",
        "title": "Introduction to Object-Oriented Programming (OOP)",
        "order": 4,
        "topics": [
          {
            "topic_id": "c93bc989-4aec-4c82-be94-9966b3491d95",
            "title": "Classes and Objects",
            "content": "Learn the basics of classes and objects in Python.",
            "xp_reward": 80,
            "cards": [
              {
                "card_id": "3f4bdf05-55be-4985-9054-da353f4bc4d4",
                "type": "theory",
                "content": "A class defines a blueprint for creating objects. Use the `class` keyword.",
                "xp_reward": 10,
                "explanation": "Objects are instances of classes."
              },
              {
                "card_id": "1231b56e-eb78-47f5-bfbc-df2cf9cd0606",
                "type": "mcq",
                "content": "Which keyword is used to define a class in Python?",
                "xp_reward": 10,
                "explanation": "Use the `class` keyword to define a class.",
                "choices": [
                  "class",
                  "def",
                  "struct",
                  "object"
                ],
                "correct_choice_index": 0
              },
              {
                "card_id": "f811074f-7a94-4fcd-8ba7-bed60150839c",
                "type": "code",
                "content": "Create a class `Car` with attributes `brand` and `year`. Create an object and print its details.",
                "xp_reward": 60,
                "explanation": "Use __init__() to initialize class attributes.",
                "starter_code": "class Car:\n    def __init__(self, brand, year):\n        # Initialize attributes\n\n# Create an object of Car and print its brand and year",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "Tesla\n2024"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "_id": "68f87f7629f86830b07c877a",
    "title": "Practical Machine Learning",
    "description": "Master Machine Learning by building real-world AI projects — from classical models to YOLO, BERT, and RAG. Learn through code, theory, and interactive challenges.",
    "slug": "practical-machine-learning",
    "xp_reward": 1000,
    "created_at": "2025-10-22T06:53:42.754000",
    "updated_at": "2025-10-22T06:53:42.754000",
    "modules": [
      {
        "module_id": "808282b3-032e-4128-b399-e8e6602c5a8b",
        "title": "What is Machine Learning? (Supervised vs. Unsupervised)",
        "order": 1,
        "topics": [
          {
            "topic_id": "b4985462-4f71-4a42-8644-d32c622e87ab",
            "title": "Introduction to ML",
            "content": "Understand what Machine Learning is, how it differs from traditional programming, and its core types.",
            "xp_reward": 60,
            "cards": [
              {
                "card_id": "b96d4c37-ed81-4a9c-be18-0e71542aacf1",
                "type": "theory",
                "content": "Machine Learning is the field of AI that enables systems to learn from data and make predictions without being explicitly programmed.",
                "xp_reward": 10,
                "explanation": "Unlike hard-coded logic, ML models infer patterns automatically."
              },
              {
                "card_id": "09c84574-4f73-4262-b47f-59bbb00a72c6",
                "type": "mcq",
                "content": "Which of the following best defines Machine Learning?",
                "xp_reward": 10,
                "explanation": "Machine Learning uses data and algorithms to mimic human learning.",
                "choices": [
                  "Programming computers using explicit rules",
                  "Using data to enable computers to learn patterns",
                  "Creating databases to store data",
                  "Building static websites"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "47bfe089-a974-4279-a605-72bc25e52417",
                "type": "fill-in-blank",
                "content": "In supervised learning, models are trained on _____ data.",
                "xp_reward": 10,
                "explanation": "Labeled data includes both input features and known outputs.",
                "blanks": [
                  "blank"
                ],
                "correct_answers": [
                  "labeled"
                ]
              },
              {
                "card_id": "a7c85fd0-0247-4d4e-99b2-d7b22f0aafde",
                "type": "theory",
                "content": "In unsupervised learning, models find hidden structures or clusters within data without labels.",
                "xp_reward": 10,
                "explanation": "Examples include K-Means clustering and dimensionality reduction."
              },
              {
                "card_id": "48a12df7-d184-4951-9f89-9d4f641e1168",
                "type": "code",
                "content": "Import scikit-learn and print its version to confirm installation.",
                "xp_reward": 20,
                "explanation": "This ensures scikit-learn is installed properly.",
                "starter_code": "import sklearn\nprint(sklearn.__version__)",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "1.5.0"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "0ab3926d-72c9-45a7-8d45-23f07a67bdf9",
                "type": "mcq",
                "content": "Which learning paradigm uses labeled input-output pairs to train models?",
                "xp_reward": 10,
                "explanation": "Supervised learning uses labeled examples.",
                "choices": [
                  "Reinforcement Learning",
                  "Unsupervised Learning",
                  "Supervised Learning",
                  "Self-supervised Learning"
                ],
                "correct_choice_index": 2
              },
              {
                "card_id": "5b995560-d68d-4041-a220-b880f85728f8",
                "type": "theory",
                "content": "A good ML workflow includes data collection, cleaning, feature engineering, modeling, evaluation, and deployment.",
                "xp_reward": 10,
                "explanation": "Understanding the full pipeline helps you build production-ready models."
              },
              {
                "card_id": "40801a05-41d7-4874-afe9-842fde5974a5",
                "type": "code",
                "content": "Split a dataset into train and test sets using scikit-learn's `train_test_split`. (Demonstration code)",
                "xp_reward": 20,
                "explanation": "Use train_test_split to split datasets for evaluation.",
                "starter_code": "from sklearn.model_selection import train_test_split\nX = [[i] for i in range(10)]\ny = list(range(10))\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\nprint(len(X_train), len(X_test))",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "8 2"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          }
        ]
      },
      {
        "module_id": "e5fb5973-2175-4c93-bd05-7817a0065434",
        "title": "Data Science Toolkit (Pandas & NumPy Basics)",
        "order": 2,
        "topics": [
          {
            "topic_id": "32fe2a9e-0280-4ab9-a44c-a37b5a77ec73",
            "title": "Working with Pandas",
            "content": "Learn how to manipulate data using Pandas — the backbone of any ML workflow.",
            "xp_reward": 60,
            "cards": [
              {
                "card_id": "5f89f964-432b-4a64-b346-c06e278fcd00",
                "type": "theory",
                "content": "Pandas provides DataFrame and Series objects for structured data manipulation.",
                "xp_reward": 10,
                "explanation": "It is the go-to tool for data cleaning and preprocessing."
              },
              {
                "card_id": "f38ef3ac-a58c-475f-a225-8068b5ccf6b5",
                "type": "mcq",
                "content": "What is the main data structure used in Pandas for tabular data?",
                "xp_reward": 10,
                "explanation": "DataFrames are 2D, labeled data structures with columns of potentially different types.",
                "choices": [
                  "DataFrame",
                  "Matrix",
                  "Array",
                  "Tensor"
                ],
                "correct_choice_index": 0
              },
              {
                "card_id": "a5eee687-f758-4da1-bf9a-2b4524a6f929",
                "type": "code",
                "content": "Create a Pandas DataFrame with a column 'Name' containing ['Alice', 'Bob'] and print it.",
                "xp_reward": 40,
                "explanation": "You can create DataFrames from dictionaries or lists.",
                "starter_code": "import pandas as pd\n# Your code here",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "   Name\n0  Alice\n1    Bob"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "b1e9e2b7-ec9c-4058-b3fb-61bf570681e4",
                "type": "code",
                "content": "Create a DataFrame with columns 'Name' and 'Age' and show how to select the 'Age' column.",
                "xp_reward": 30,
                "explanation": "Selecting a single column returns a Series.",
                "starter_code": "import pandas as pd\ndf = pd.DataFrame({'Name':['Alice','Bob'],'Age':[25,30]})\nprint(df['Age'])",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "0    25\n1    30\nName: Age, dtype: int64"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "8b106f49-0edf-41fe-b017-dd89acc5b7cb",
                "type": "mcq",
                "content": "Which Pandas method removes rows with missing values?",
                "xp_reward": 10,
                "explanation": "`dropna()` removes rows (or columns) with NA values.",
                "choices": [
                  "dropna()",
                  "fillna()",
                  "remove_na()",
                  "clean_na()"
                ],
                "correct_choice_index": 0
              },
              {
                "card_id": "c9f8b690-228b-4633-906e-d29d9bd91fb6",
                "type": "theory",
                "content": "Method chaining (e.g., `df.dropna().reset_index(drop=True)`) improves readability and avoids intermediate variables.",
                "xp_reward": 10,
                "explanation": "Chaining makes pipelines concise and expressive."
              }
            ]
          },
          {
            "topic_id": "406c3cc8-e136-4541-ab96-b4dcb3d81184",
            "title": "NumPy Fundamentals",
            "content": "NumPy is used for fast numerical computations and matrix operations.",
            "xp_reward": 50,
            "cards": [
              {
                "card_id": "6885bc25-1826-44e4-bef7-1969a63b041b",
                "type": "theory",
                "content": "NumPy arrays are more efficient than Python lists for numerical operations.",
                "xp_reward": 10,
                "explanation": "They support element-wise operations and broadcasting."
              },
              {
                "card_id": "6aecf26d-e0b2-41a3-b1d4-852528fef00d",
                "type": "mcq",
                "content": "Which function creates an array of zeros in NumPy?",
                "xp_reward": 10,
                "explanation": "`np.zeros()` creates an array filled with zeros.",
                "choices": [
                  "np.empty()",
                  "np.zeros()",
                  "np.fill()",
                  "np.null()"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "5ac63e51-c32b-44c5-8976-135fc4f53e66",
                "type": "code",
                "content": "Create a NumPy array [1, 2, 3, 4] and print its mean.",
                "xp_reward": 30,
                "explanation": "Use `np.mean()` to find the average of an array.",
                "starter_code": "import numpy as np\n# Your code here",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "2.5"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "02091ce0-a024-459e-b079-0c7c87d9c8be",
                "type": "code",
                "content": "Demonstrate NumPy broadcasting by adding a vector to each row of a matrix.",
                "xp_reward": 30,
                "explanation": "Broadcasting expands the smaller array across the larger one.",
                "starter_code": "import numpy as np\nA = np.array([[1,2,3],[4,5,6]])\nb = np.array([10,20,30])\nprint(A + b)",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "[[11 22 33]\n [14 25 36]]"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "2af80a8e-61ae-43e2-9359-31a8c0378296",
                "type": "mcq",
                "content": "What NumPy dtype would best hold decimal values?",
                "xp_reward": 10,
                "explanation": "float64 is the default floating-point dtype in NumPy.",
                "choices": [
                  "int32",
                  "float64",
                  "bool",
                  "object"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "7b7817e5-cf30-4d9c-8d9d-e20468f25b02",
                "type": "theory",
                "content": "Vectorized operations in NumPy are implemented in C and are much faster than Python loops.",
                "xp_reward": 10,
                "explanation": "Use vectorized operations for performance."
              }
            ]
          }
        ]
      },
      {
        "module_id": "ea67eb83-b3db-45ab-917d-78dae0ff45a0",
        "title": "Building Your First Model (Scikit-learn)",
        "order": 3,
        "topics": [
          {
            "topic_id": "2a8fe92d-ee23-4fa8-8bf6-40ad812f54bf",
            "title": "Linear Regression Basics",
            "content": "Learn to train your first predictive model using scikit-learn.",
            "xp_reward": 80,
            "cards": [
              {
                "card_id": "1ca565fa-6cfb-481d-8f99-dcd7bea4e956",
                "type": "theory",
                "content": "Linear Regression predicts a target variable by fitting a linear relationship with features.",
                "xp_reward": 10,
                "explanation": "It’s one of the simplest and most interpretable ML algorithms."
              },
              {
                "card_id": "1bc38186-d6cc-4931-b13c-e141d5a980b8",
                "type": "code",
                "content": "Train a simple Linear Regression model using scikit-learn on X=[1,2,3] and y=[2,4,6], then print the slope.",
                "xp_reward": 70,
                "explanation": "The model learns y = 2x, so the coefficient is 2.",
                "starter_code": "from sklearn.linear_model import LinearRegression\nimport numpy as np\n\nX = np.array([[1],[2],[3]])\ny = np.array([2,4,6])\n\n# Your code here",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "2.0"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "e8b9f20b-80ff-49f9-91d0-00bdcb9c0647",
                "type": "mcq",
                "content": "In simple linear regression y = mx + c, what does 'm' represent?",
                "xp_reward": 10,
                "explanation": "The coefficient (slope) scales the input feature.",
                "choices": [
                  "Intercept",
                  "Slope/Coefficient",
                  "Noise",
                  "Prediction"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "b55e31db-c05d-423a-accf-8cf9212eec9e",
                "type": "code",
                "content": "After training a linear regression model, use it to predict for X=[[4]] and print the prediction.",
                "xp_reward": 30,
                "explanation": "Model trained on y=2x predicts 8 for x=4.",
                "starter_code": "from sklearn.linear_model import LinearRegression\nimport numpy as np\nX = np.array([[1],[2],[3]])\ny = np.array([2,4,6])\nmodel = LinearRegression().fit(X,y)\nprint(model.predict([[4]])[0])",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "8.0"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "795baabc-c92a-4cd7-b5b5-c90f76f69488",
                "type": "theory",
                "content": "Inspecting coefficients and residuals helps you diagnose model fit and bias.",
                "xp_reward": 10,
                "explanation": "Residual analysis reveals systematic errors."
              }
            ]
          }
        ]
      },
      {
        "module_id": "ede80c7d-d00a-4270-b8a4-b44d1e71dbe4",
        "title": "Introduction to Deep Learning (How Neural Networks Work)",
        "order": 4,
        "topics": [
          {
            "topic_id": "4ae18c05-8f29-4c44-a9fe-5ac00837e448",
            "title": "Neural Network Fundamentals",
            "content": "Understand how neurons, weights, and activations work together to form learning systems.",
            "xp_reward": 70,
            "cards": [
              {
                "card_id": "86ca4c99-5450-4470-a65b-f5ba6bcd1209",
                "type": "theory",
                "content": "A neural network consists of layers of interconnected nodes (neurons) that learn hierarchical representations.",
                "xp_reward": 10,
                "explanation": "Each neuron applies a weighted sum followed by an activation function."
              },
              {
                "card_id": "d16d0b31-0c0f-4c95-82c5-5a09f7c2c7de",
                "type": "mcq",
                "content": "Which activation function introduces non-linearity?",
                "xp_reward": 10,
                "explanation": "Both Sigmoid and ReLU introduce non-linearity into neural networks.",
                "choices": [
                  "Sigmoid",
                  "ReLU",
                  "Both A and B",
                  "Linear"
                ],
                "correct_choice_index": 2
              },
              {
                "card_id": "7500f14b-43c7-4c9e-b8fe-e0197d648253",
                "type": "fill-in-blank",
                "content": "The process of updating weights based on error is called _____.",
                "xp_reward": 10,
                "explanation": "Backpropagation uses gradient descent to minimize the loss function.",
                "blanks": [
                  "blank"
                ],
                "correct_answers": [
                  "backpropagation"
                ]
              },
              {
                "card_id": "3e9fcb45-c1d1-43e3-9ac0-814f0fd8c7e9",
                "type": "theory",
                "content": "Deep Learning is an extension of ML using multi-layered neural networks for complex feature learning.",
                "xp_reward": 10,
                "explanation": "It powers modern AI systems like ChatGPT, vision models, and voice recognition."
              },
              {
                "card_id": "2694445d-6fe7-4029-894e-9552f5f97c06",
                "type": "mcq",
                "content": "Which problem is typically addressed by adding more data or regularization?",
                "xp_reward": 10,
                "explanation": "Regularization and more data help reduce overfitting.",
                "choices": [
                  "Underfitting",
                  "Overfitting",
                  "Compilation Error",
                  "Syntax Error"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "22d88bd2-31b8-40f1-9238-1325521d544d",
                "type": "theory",
                "content": "Common regularization methods include L1/L2 penalties, dropout, and early stopping.",
                "xp_reward": 10,
                "explanation": "They prevent the model from memorizing the training set."
              },
              {
                "card_id": "0aa1afda-646d-4adc-9b73-57f96468e5b5",
                "type": "code",
                "content": "Calculate simple accuracy given y_true and y_pred lists.",
                "xp_reward": 20,
                "explanation": "Accuracy is fraction correct.",
                "starter_code": "y_true = [0,1,1,0]\ny_pred = [0,1,0,0]\nacc = sum(1 for a,b in zip(y_true,y_pred) if a==b) / len(y_true)\nprint(acc)",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "0.75"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          }
        ]
      },
      {
        "module_id": "499fc3fb-c3c3-43ca-94ec-3e994a56df63",
        "title": "Computer Vision with YOLO (Advanced)",
        "order": 5,
        "topics": [
          {
            "topic_id": "f470a998-6ec9-462c-86a7-ec89b78fcd3c",
            "title": "Real-time Object Detection",
            "content": "Learn how YOLO (You Only Look Once) detects multiple objects in real-time.",
            "xp_reward": 100,
            "cards": [
              {
                "card_id": "4520ac31-0834-4362-a5e7-9d36277f05cb",
                "type": "theory",
                "content": "YOLO divides an image into grids and predicts bounding boxes and class probabilities directly from pixels.",
                "xp_reward": 10,
                "explanation": "It’s fast and efficient, ideal for real-time vision systems."
              },
              {
                "card_id": "5ec3a4d6-8a0e-4a70-8cf2-45dd467e5f44",
                "type": "mcq",
                "content": "What does YOLO stand for?",
                "xp_reward": 10,
                "explanation": "YOLO stands for 'You Only Look Once'.",
                "choices": [
                  "You Only Learn Once",
                  "You Only Look Once",
                  "Your Output Learns Objects",
                  "None"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "8317cbef-0fb0-4676-a335-ef0a877c2562",
                "type": "code",
                "content": "Write a Python snippet to load a YOLO model using ultralytics and print model info.",
                "xp_reward": 80,
                "explanation": "Use `model = YOLO('yolov8n.pt')` to load pretrained weights.",
                "starter_code": "from ultralytics import YOLO\n\n# Your code here",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "YOLOv8n summary"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "a8996502-2424-43df-99f5-b1311584b633",
                "type": "mcq",
                "content": "Which technique helps reduce overlapping bounding boxes in object detection?",
                "xp_reward": 10,
                "explanation": "NMS suppresses overlapping boxes keeping the best-scoring one.",
                "choices": [
                  "Batch Normalization",
                  "Non-Maximum Suppression",
                  "Dropout",
                  "Data Augmentation"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "f2cf4f42-b61d-4da7-b2c9-d4cdcaf009b4",
                "type": "theory",
                "content": "YOLO predicts bounding boxes relative to grid cells and uses anchor boxes for scale variance.",
                "xp_reward": 10,
                "explanation": "Anchors help predict different object sizes."
              },
              {
                "card_id": "46a5ee4e-1756-4809-985f-da1382b3dfa0",
                "type": "code",
                "content": "Example: show how to instantiate a YOLO model object using ultralytics (demo code).",
                "xp_reward": 20,
                "explanation": "This demonstrates loading pretrained weights (no execution required here).",
                "starter_code": "from ultralytics import YOLO\nmodel = YOLO('yolov8n.pt')\nprint('Loaded model:', type(model))",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "Loaded model:"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          }
        ]
      },
      {
        "module_id": "b7b70fb2-d37d-4937-9b9e-7adbd2ce0a9f",
        "title": "NLP with BERT & RAG (Advanced)",
        "order": 6,
        "topics": [
          {
            "topic_id": "bd972197-94c3-439b-9a24-f6480cabf411",
            "title": "Transformers and BERT",
            "content": "Learn the foundation of transformer models and how BERT understands language.",
            "xp_reward": 100,
            "cards": [
              {
                "card_id": "428aef71-eb60-46a9-a128-3cce50d67b09",
                "type": "theory",
                "content": "BERT (Bidirectional Encoder Representations from Transformers) learns context from both directions of a sentence.",
                "xp_reward": 10,
                "explanation": "It revolutionized NLP by enabling deeper understanding of sentence semantics."
              },
              {
                "card_id": "a2c251a3-ed8b-473c-abc0-a49488228454",
                "type": "mcq",
                "content": "What is the main architectural component of BERT?",
                "xp_reward": 10,
                "explanation": "BERT uses stacked Transformer Encoders.",
                "choices": [
                  "CNN",
                  "RNN",
                  "Transformer Encoder",
                  "Decision Tree"
                ],
                "correct_choice_index": 2
              },
              {
                "card_id": "98e7512c-56fe-4ee9-8564-d9cfa44e1b1e",
                "type": "code",
                "content": "Use Hugging Face Transformers to load 'bert-base-uncased' and print the model config.",
                "xp_reward": 50,
                "explanation": "Ensure transformers library is installed and model downloads correctly.",
                "starter_code": "from transformers import AutoModel\nmodel = AutoModel.from_pretrained('bert-base-uncased')\nprint(model.config)",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "BertConfig"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "7418fc84-a1bf-4e3a-b9bd-6a8939d40fe8",
                "type": "code",
                "content": "Use Hugging Face tokenizer to tokenize a short sentence (demo).",
                "xp_reward": 30,
                "explanation": "Tokenization splits input into model tokens.",
                "starter_code": "from transformers import AutoTokenizer\ntokenizer = AutoTokenizer.from_pretrained('bert-base-uncased')\nprint(tokenizer.tokenize('Hello world'))",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "['hello', 'world']"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "b9f6ab70-5d9f-4113-ab37-2f7dbfde5449",
                "type": "mcq",
                "content": "BERT is trained using which pretraining tasks?",
                "xp_reward": 10,
                "explanation": "BERT uses MLM and NSP during pretraining.",
                "choices": [
                  "Next Sentence Prediction and Masked Language Modeling",
                  "Causal Language Modeling",
                  "Image Captioning",
                  "Reinforcement Learning"
                ],
                "correct_choice_index": 0
              },
              {
                "card_id": "623c1048-1ab0-486a-a413-019697e5ff4a",
                "type": "theory",
                "content": "Transformer models rely on self-attention to model relationships between tokens regardless of distance.",
                "xp_reward": 10,
                "explanation": "Self-attention enables context-aware representations."
              }
            ]
          },
          {
            "topic_id": "5cb29132-b23c-4733-b27b-247bc8ceeff7",
            "title": "Retrieval-Augmented Generation (RAG)",
            "content": "Understand how RAG combines retrieval and generation for advanced QA and chatbot systems.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "3d3ba001-2968-4443-813c-f738dba11d8f",
                "type": "theory",
                "content": "RAG merges dense retrieval with generative models (like BERT + GPT) to create context-aware responses.",
                "xp_reward": 10,
                "explanation": "It retrieves relevant documents before generating an answer."
              },
              {
                "card_id": "1f4631cf-f9b7-43fe-a14d-d82aa00d8b43",
                "type": "code",
                "content": "Simulate a RAG workflow by defining a retriever (list of docs) and returning top match for a query.",
                "xp_reward": 80,
                "explanation": "You can later replace this logic with FAISS or Chroma for real vector retrieval.",
                "starter_code": "docs = ['AI improves healthcare', 'GNNs are powerful for graphs', 'YOLO detects objects']\nquery = 'graph learning'\n# Your code here: find doc with 'graph'",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "GNNs are powerful for graphs"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "0836c042-c8e0-450d-bc19-e9b282abab18",
                "type": "mcq",
                "content": "What is the main purpose of the retrieval component in RAG systems?",
                "xp_reward": 10,
                "explanation": "Retrieval provides relevant documents to inform generation.",
                "choices": [
                  "Generate text from scratch",
                  "Retrieve relevant context to condition generation",
                  "Translate languages",
                  "Compress documents"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "cbd5983e-1919-4598-a786-fc6cff780e52",
                "type": "code",
                "content": "Simple ranking: choose the document with the highest keyword match count for a query.",
                "xp_reward": 30,
                "explanation": "This is a naive keyword-based retriever.",
                "starter_code": "docs = ['AI improves healthcare', 'GNNs are powerful for graphs', 'YOLO detects objects']\nquery = 'graph learning'\nbest = max(docs, key=lambda d: sum(1 for w in query.split() if w in d.lower()))\nprint(best)",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "GNNs are powerful for graphs"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "2565a719-00bb-483e-b3ba-5526e4388446",
                "type": "theory",
                "content": "RAG systems combine retrieval for grounding and generation for fluent answers; both parts must be evaluated.",
                "xp_reward": 10,
                "explanation": "Metrics include retrieval precision and generation quality."
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "_id": "68f8981d1515e67cdf472464",
    "title": "Python Intermediate: Advanced Features and OOP",
    "description": "Transition to an intermediate level by mastering functional programming tools, advanced data structures, file I/O, and the principles of Object-Oriented Programming (OOP).",
    "slug": "python-intermediate-advanced-features-and-oop",
    "xp_reward": 1500,
    "created_at": "2025-10-22T08:38:53.961000",
    "updated_at": "2025-10-22T08:38:53.961000",
    "modules": [
      {
        "module_id": "d963ddd2-1f5d-43f8-a59f-ce26e5b9d748",
        "title": "Module 1: Functional Programming Tools",
        "order": 1,
        "topics": [
          {
            "topic_id": "c6eb4614-2a3f-42ac-8f81-abf3fd68e14c",
            "title": "List Comprehensions and Set Comprehensions",
            "content": "Master Python's concise syntax for creating lists, sets, and dictionaries using comprehensions.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "fc86fd83-4440-4a19-8814-a41ea9299dba",
                "type": "theory",
                "content": "List comprehensions offer a concise way to create lists in a single line.",
                "xp_reward": 10,
                "explanation": "They replace traditional `for` loops for list generation."
              },
              {
                "card_id": "9d369580-ebfd-40d5-9cf6-e5e6c0db3b72",
                "type": "code",
                "content": "Create a list of even numbers from 0 up to 10 (inclusive) using list comprehension.",
                "xp_reward": 30,
                "explanation": "Use `[i for i in range(11) if i % 2 == 0]`.",
                "starter_code": "def even_numbers():\n    # Return list of even numbers from 0 to 10\n    pass",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "[0, 2, 4, 6, 8, 10]"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "f31077e8-5d50-4c1e-a4ee-a5637fbd584e",
                "type": "mcq",
                "content": "Which comprehension creates an immutable collection of unique elements?",
                "xp_reward": 10,
                "explanation": "Set comprehensions enforce uniqueness using `{}`.",
                "choices": [
                  "List",
                  "Dictionary",
                  "Set",
                  "Tuple"
                ],
                "correct_choice_index": 2
              }
            ]
          },
          {
            "topic_id": "54dc50c6-0930-4685-830d-06a1f6d560da",
            "title": "Map and Filter Functions",
            "content": "Use higher-order functions for data transformation and selection.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "f0c2f689-bdc4-4995-b520-1b2f0d74834e",
                "type": "theory",
                "content": "`map()` applies a function to every element of an iterable and returns an iterator.",
                "xp_reward": 10,
                "explanation": "Useful for functional programming."
              },
              {
                "card_id": "475f2b07-9cbe-43e4-b9c0-1251e33ffcbe",
                "type": "code",
                "content": "Use map to cube all elements in a list.",
                "xp_reward": 30,
                "explanation": "Convert map object to list before returning.",
                "starter_code": "def cube_list(nums):\n    # Return list with elements cubed\n    pass",
                "test_cases": [
                  {
                    "input": "[1,2,3]",
                    "expected_output": "[1, 8, 27]"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "7d074daf-73ee-4e40-b179-c2df32a14877",
                "type": "fill_blank",
                "content": "`filter()` constructs an iterator from elements of an iterable for which a function returns _____.",
                "xp_reward": 10,
                "explanation": "It selects elements based on a condition."
              }
            ]
          },
          {
            "topic_id": "e5963381-2a17-4bab-971e-77d19430518f",
            "title": "Generator Expressions",
            "content": "Create memory-efficient iterators using generator expressions.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "6b2140ff-044b-425c-b093-5351cdc78735",
                "type": "theory",
                "content": "Generator expressions use parentheses and yield items one at a time.",
                "xp_reward": 10,
                "explanation": "Useful for large data sets to save memory."
              },
              {
                "card_id": "4e3ee64d-38cc-40d9-8f30-9089af326d5f",
                "type": "mcq",
                "content": "Key difference between a list comprehension and a generator expression?",
                "xp_reward": 10,
                "explanation": "Generators produce an iterator, not a list.",
                "choices": [
                  "Syntax",
                  "Type",
                  "Speed",
                  "Immutability"
                ],
                "correct_choice_index": 1
              }
            ]
          }
        ]
      },
      {
        "module_id": "40cb442c-95ef-4ba0-9bcb-026129e67b29",
        "title": "Module 2: Advanced Functions and Decorators",
        "order": 2,
        "topics": [
          {
            "topic_id": "8039ef21-8088-4b9a-82cc-f25214df003a",
            "title": "Lambda Functions and Sorting",
            "content": "Use lambda for inline functions and custom sorting.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "8473f75b-0781-4c02-a56d-5f0d9e063d01",
                "type": "theory",
                "content": "Lambda functions are small anonymous functions with a single expression.",
                "xp_reward": 10,
                "explanation": "Ideal for quick inline function definitions."
              },
              {
                "card_id": "e315ea0d-8c8d-4618-9c55-ec8b9e6d708f",
                "type": "code",
                "content": "Sort a list of names by their length using lambda.",
                "xp_reward": 30,
                "explanation": "Use `sorted(list, key=lambda x: len(x))`.",
                "starter_code": "def sort_by_length(names):\n    # Return names sorted by length\n    pass",
                "test_cases": [
                  {
                    "input": "['Bob', 'Alice', 'Charlie']",
                    "expected_output": "['Bob', 'Alice', 'Charlie']"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          },
          {
            "topic_id": "7eb9d4b8-9394-4b53-a551-026f2a084df3",
            "title": "Function Arguments: *args and **kwargs",
            "content": "Learn to handle arbitrary numbers of arguments in functions.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "fef51df4-3db2-4c13-93c0-a0870f4cba3e",
                "type": "fill_blank",
                "content": "The LEGB rule defines scope lookup: Local, Enclosing, Global, and _____.",
                "xp_reward": 10,
                "explanation": "Determines variable resolution."
              },
              {
                "card_id": "10d3509d-b905-4fa0-9d0a-097a6dbbec27",
                "type": "code",
                "content": "Write a function that prints the value of 'city' from kwargs.",
                "xp_reward": 30,
                "explanation": "Access `kwargs['city']`.",
                "starter_code": "def print_city(**kwargs):\n    # Print value of 'city'\n    pass",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "New York"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          },
          {
            "topic_id": "6ff844cf-432b-4489-8c18-b9a58e49e9ec",
            "title": "Closures and First-class Functions",
            "content": "Understand closures and how functions can be passed as objects.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "f7aab5db-9e98-48af-b17d-5c6b3d7eafa1",
                "type": "theory",
                "content": "Functions are first-class citizens in Python.",
                "xp_reward": 10,
                "explanation": "They can be passed as arguments, returned from functions, and assigned to variables."
              },
              {
                "card_id": "61d90d56-dd26-4add-9138-ba3dbe82954a",
                "type": "fill_blank",
                "content": "A function that remembers values from enclosing scope is called a _____.",
                "xp_reward": 10,
                "explanation": "Closures carry a reference to their environment."
              }
            ]
          }
        ]
      },
      {
        "module_id": "825c430f-4bfb-428d-9763-b225f74f5550",
        "title": "Module 3: Object-Oriented Programming Basics",
        "order": 3,
        "topics": [
          {
            "topic_id": "14eb44c8-debb-4266-93ce-7e57b3947f0e",
            "title": "Classes and Objects",
            "content": "Define classes and create objects, understanding attributes and methods.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "f6af44ce-0a71-42e0-921d-042fab2b917b",
                "type": "theory",
                "content": "A class is a blueprint; an object is an instance of the class.",
                "xp_reward": 10,
                "explanation": ""
              },
              {
                "card_id": "5f3a8367-9f7d-4c2b-a495-725bcb08fca8",
                "type": "fill_blank",
                "content": "The first parameter of an instance method is _____.",
                "xp_reward": 10,
                "explanation": ""
              },
              {
                "card_id": "2bd52311-45e6-4e3c-b662-481347b442a2",
                "type": "code",
                "content": "Create a class Book with class attribute 'material'='paper' and return it.",
                "xp_reward": 30,
                "explanation": "",
                "starter_code": "def get_book_material():\n    # Return the material of a Book instance\n    pass",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "paper"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          },
          {
            "topic_id": "63701328-1a50-49b1-8c04-5941cb26031a",
            "title": "Constructors and Instance Methods",
            "content": "Learn to initialize objects and define their behaviors.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "21ef4cd9-0c3c-469f-8ccd-7ca6a5259744",
                "type": "code",
                "content": "Create a Circle class with __init__ accepting radius. Return radius.",
                "xp_reward": 30,
                "explanation": "",
                "starter_code": "def create_circle(radius):\n    # Return radius of the Circle instance\n    pass",
                "test_cases": [
                  {
                    "input": "5",
                    "expected_output": "5"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "0d5aa53e-32fc-4d28-a2bd-b28ba35d5d05",
                "type": "mcq",
                "content": "What is the process of creating an object from a class called?",
                "xp_reward": 10,
                "explanation": "",
                "choices": [
                  "Declaration",
                  "Construction",
                  "Instantiation",
                  "Inheritance"
                ],
                "correct_choice_index": 2
              }
            ]
          },
          {
            "topic_id": "40e5791d-5d1b-4862-a41d-5246e8fe3b8b",
            "title": "Encapsulation and Private Attributes",
            "content": "Learn to protect object data using private attributes.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "9a6b20ef-4d64-49f0-88b4-c256c1fbc0f2",
                "type": "theory",
                "content": "Encapsulation bundles attributes and methods in a class and restricts access by convention.",
                "xp_reward": 10,
                "explanation": ""
              },
              {
                "card_id": "31a87a8d-c19b-4c48-a76b-babf857bc48e",
                "type": "theory",
                "content": "Double underscores cause name mangling to protect attributes.",
                "xp_reward": 10,
                "explanation": ""
              }
            ]
          }
        ]
      },
      {
        "module_id": "81cb092b-1905-49c6-97aa-ce0cf5ad5717",
        "title": "Module 4: Inheritance and Polymorphism",
        "order": 4,
        "topics": [
          {
            "topic_id": "0937e841-99c1-4e11-a7ee-00f23b3dc9bd",
            "title": "Basic Inheritance",
            "content": "Understand subclassing and inheriting methods and attributes.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "8aa9e872-84a6-48db-83d6-5dc900886c9c",
                "type": "mcq",
                "content": "To define Dog class inheriting Animal, which is correct?",
                "xp_reward": 10,
                "explanation": "",
                "choices": [
                  "class Dog: Animal",
                  "class Dog extends Animal",
                  "class Dog(Animal)",
                  "class Dog inherits Animal"
                ],
                "correct_choice_index": 2
              },
              {
                "card_id": "30d7247f-7c5d-472b-be2b-97f84b963dd3",
                "type": "fill_blank",
                "content": "Call parent __init__ using _____.",
                "xp_reward": 10,
                "explanation": ""
              }
            ]
          },
          {
            "topic_id": "b7cac390-9472-465f-9b73-192035dc6aef",
            "title": "Method Overriding",
            "content": "Override methods in subclasses to provide specific behavior.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "d1060139-82af-4b46-96f3-328419930737",
                "type": "code",
                "content": "Define Animal.sound returning 'Generic sound'. Override in Cat to return 'Meow'.",
                "xp_reward": 40,
                "explanation": "",
                "starter_code": "def cat_sound():\n    # Return 'Meow' from Cat instance\n    pass",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "Meow"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          },
          {
            "topic_id": "2ada1f21-afc3-4f50-88f3-61b4332dae32",
            "title": "Polymorphism",
            "content": "Understand objects responding differently to the same method call.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "bea00dde-be86-457b-b552-c2718c393ae5",
                "type": "theory",
                "content": "Polymorphism allows different classes to respond to the same method call.",
                "xp_reward": 10,
                "explanation": ""
              }
            ]
          }
        ]
      },
      {
        "module_id": "2c9fd75e-ca27-4934-98bd-d65ac74b944c",
        "title": "Module 5: Error Handling and File I/O",
        "order": 5,
        "topics": [
          {
            "topic_id": "0b36383d-e620-4f43-9a06-3fea3a5a706a",
            "title": "Try/Except and Custom Errors",
            "content": "Handle runtime errors gracefully and raise custom exceptions.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "0e924c3d-3943-40cc-b933-6973ec5ead5b",
                "type": "code",
                "content": "Handle ZeroDivisionError when dividing 10 by 0 and return 'Cannot divide by zero'.",
                "xp_reward": 40,
                "explanation": "",
                "starter_code": "def safe_division():\n    # Handle ZeroDivisionError\n    pass",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "Cannot divide by zero"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "05941ca4-0227-4f6f-867f-bbce2699ba38",
                "type": "mcq",
                "content": "Which statement manually triggers an exception?",
                "xp_reward": 10,
                "explanation": "",
                "choices": [
                  "throw",
                  "raise",
                  "except",
                  "error"
                ],
                "correct_choice_index": 1
              }
            ]
          },
          {
            "topic_id": "d3072586-973e-499f-b244-ee998ca93196",
            "title": "File Reading and Writing",
            "content": "Perform basic file I/O operations.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "3d9088ef-b87f-43ab-a770-bf6ac48eb643",
                "type": "code",
                "content": "Write 'Python' to 'output.txt' using a context manager.",
                "xp_reward": 40,
                "explanation": "",
                "starter_code": "def write_file():\n    # Write 'Python' to file\n    pass",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": ""
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "729a8ee9-71d1-4e0a-98bf-309968f12c13",
                "type": "mcq",
                "content": "Method to read entire file into a string?",
                "xp_reward": 10,
                "explanation": "",
                "choices": [
                  "f.read_line()",
                  "f.read_all()",
                  "f.readlines()",
                  "f.read()"
                ],
                "correct_choice_index": 3
              }
            ]
          },
          {
            "topic_id": "7590050e-14c2-4244-a277-5d592e69b7d8",
            "title": "File Line Processing",
            "content": "Process file line by line efficiently.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "de93eeca-6809-485b-8d0b-fd887c3e2e53",
                "type": "theory",
                "content": "`f.readlines()` returns a list of file lines.",
                "xp_reward": 10,
                "explanation": ""
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "_id": "68f8b5aa929f4cb9a87b5102",
    "title": "C Programming Basics: From Syntax to Logic",
    "description": "Master the fundamentals of the C programming language — from variables and operators to loops, functions, and arrays. Build a solid foundation for system-level and embedded programming.",
    "slug": "c-programming-basics-from-syntax-to-logic",
    "xp_reward": 1200,
    "created_at": "2025-10-22T10:44:58.892000",
    "updated_at": "2025-10-22T15:12:53.941000",
    "modules": [
      {
        "module_id": "559da784-bc77-45ba-b099-46a264208e5f",
        "title": "Module 1: Introduction to C Programming",
        "order": 1,
        "topics": [
          {
            "topic_id": "c783bb8d-e354-460a-9bc9-9bab80fc84e1",
            "title": "What is C?",
            "content": "Understand  the history, purpose, and structure of the C language.",
            "xp_reward": 100,
            "cards": [
              {
                "card_id": "3c92b6d3-ff4f-4b3b-994d-20e8bd46d062",
                "type": "theory",
                "content": "C is a general-purpose, procedural programming language developed by Dennis Ritchie in 1972 at Bell Labs.",
                "xp_reward": 10,
                "explanation": "C influenced many modern languages like C++, Java, and Python."
              },
              {
                "card_id": "a7e1f92c-267d-4c3a-a452-81ac1e2c236c",
                "type": "theory",
                "content": "C provides low-level memory access and is widely used in systems programming, embedded systems, and operating systems.",
                "xp_reward": 10,
                "explanation": ""
              },
              {
                "card_id": "e1ccab4b-4df5-47d0-8c69-f1c56e98d9b9",
                "type": "fill-in-blank",
                "content": "C language was developed by ____ at Bell Labs in 1972.",
                "xp_reward": 10,
                "explanation": "",
                "blanks": [
                  "blank"
                ],
                "correct_answers": [
                  "Dennis Ritchie"
                ]
              },
              {
                "card_id": "e66595ee-de16-4131-a421-f729733e0861",
                "type": "mcq",
                "content": "Which of the following is NOT a feature of C?",
                "xp_reward": 10,
                "explanation": "",
                "choices": [
                  "Structured Language",
                  "Machine Dependent",
                  "Portable",
                  "Object-Oriented"
                ],
                "correct_choice_index": 3
              }
            ]
          },
          {
            "topic_id": "6045afc8-ea15-4980-94b6-81a22354ad7e",
            "title": "Structure of a C Program",
            "content": "Learn the building blocks of a C program and its compilation process.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "17e2dca9-2a50-4283-ba07-eb0f4619340f",
                "type": "theory",
                "content": "A basic C program contains preprocessor directives, the main function, and statements.",
                "xp_reward": 10,
                "explanation": ""
              },
              {
                "card_id": "6f09cd18-894f-462a-b1e1-17599494694a",
                "type": "code",
                "content": "Write a C program to print 'Hello, World!'",
                "xp_reward": 30,
                "explanation": "Use printf() from stdio.h to print text.",
                "starter_code": "#include <stdio.h>\nint main() {\n    // print Hello, World!\n    return 0;\n}",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "Hello, World!"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "46b009b8-86f4-451b-b65c-bf3f510299d4",
                "type": "theory",
                "content": "Every C program must have a `main()` function as the entry point.",
                "xp_reward": 10,
                "explanation": ""
              },
              {
                "card_id": "298a3cf9-7f19-4f8d-985c-9785fcb24f13",
                "type": "fill-in-blank",
                "content": "The header file used for input/output in C is ____.",
                "xp_reward": 10,
                "explanation": "",
                "blanks": [
                  "blank"
                ],
                "correct_answers": [
                  "stdio.h"
                ]
              }
            ]
          },
          {
            "topic_id": "f95edd36-61a6-412f-aa43-4754f597862f",
            "title": "Compilation and Execution Process",
            "content": "Understand how C code is converted into an executable file.",
            "xp_reward": 100,
            "cards": [
              {
                "card_id": "336605e3-1d33-4385-a877-f3c5a40807cc",
                "type": "theory",
                "content": "Compilation in C involves preprocessing, compiling, assembling, and linking.",
                "xp_reward": 10,
                "explanation": ""
              },
              {
                "card_id": "8dfd4129-31f0-4dda-9c62-ff0465f37507",
                "type": "mcq",
                "content": "Which step of compilation converts C code to assembly code?",
                "xp_reward": 10,
                "explanation": "",
                "choices": [
                  "Preprocessing",
                  "Compilation",
                  "Linking",
                  "Execution"
                ],
                "correct_choice_index": 1
              }
            ]
          }
        ]
      },
      {
        "module_id": "092f8267-90a6-407d-822e-3ba110d85087",
        "title": "Module 2: Variables, Data Types, and Operators",
        "order": 2,
        "topics": [
          {
            "topic_id": "fcc95fbe-ab5f-4a5d-ac4d-4c361654e551",
            "title": "Variables and Constants",
            "content": "Learn how to store and manage data using variables and constants in C.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "c29c27ae-7a83-4598-88d5-2479fdeb124b",
                "type": "theory",
                "content": "Variables in C are containers for storing data values. They must be declared with a data type.",
                "xp_reward": 10,
                "explanation": ""
              },
              {
                "card_id": "5c67d851-5861-453f-8f8b-1a61b7cf4840",
                "type": "code",
                "content": "Declare an integer variable `age` with value 20 and print it.",
                "xp_reward": 30,
                "explanation": "",
                "starter_code": "#include <stdio.h>\nint main() {\n    // declare and print variable\n    return 0;\n}",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "20"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "a6ab4aba-ae6e-44d0-8585-a8ac5f6f5643",
                "type": "fill-in-blank",
                "content": "Keyword used to define constants in C is ____.",
                "xp_reward": 10,
                "explanation": "",
                "blanks": [
                  "blank"
                ],
                "correct_answers": [
                  "const"
                ]
              }
            ]
          },
          {
            "topic_id": "2a31b8b9-3146-4561-bcb9-1e5270f7280d",
            "title": "Data Types in C",
            "content": "Understand the different types of data and their storage requirements.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "792fd930-9d5f-491b-b9b9-70dfdbb7e051",
                "type": "theory",
                "content": "C has 4 primary data types: int, float, char, and double.",
                "xp_reward": 10,
                "explanation": ""
              },
              {
                "card_id": "7716e7b0-58fd-49c7-a8bf-f86a94b603a2",
                "type": "mcq",
                "content": "Which of the following stores a single character?",
                "xp_reward": 10,
                "explanation": "",
                "choices": [
                  "int",
                  "char",
                  "float",
                  "double"
                ],
                "correct_choice_index": 1
              }
            ]
          },
          {
            "topic_id": "d7a54ee9-46d5-4ab5-87af-a44c44fc313a",
            "title": "Operators in C",
            "content": "Perform operations on variables using operators.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "1c87f57c-dac2-4e07-91f0-dc242d5cb234",
                "type": "theory",
                "content": "Operators are symbols that perform operations on variables and values, e.g., `+`, `-`, `*`, `/`.",
                "xp_reward": 10,
                "explanation": ""
              },
              {
                "card_id": "f4d93d5f-98df-4968-b0c7-dbe3eefcfa4e",
                "type": "fill-in-blank",
                "content": "The modulus operator in C is represented by ____.",
                "xp_reward": 10,
                "explanation": "",
                "blanks": [
                  "blank"
                ],
                "correct_answers": [
                  "%"
                ]
              }
            ]
          }
        ]
      },
      {
        "module_id": "ab9305fa-e131-4376-8ca3-43ef04c10a8e",
        "title": "Module 3: Control Statements and Loops",
        "order": 3,
        "topics": [
          {
            "topic_id": "8bb3077d-5866-42df-82b7-47ba44c29f24",
            "title": "Conditional Statements",
            "content": "Control the flow of execution using if-else and switch statements.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "c581883d-3be5-464e-bbf2-37044bba1d69",
                "type": "theory",
                "content": "The `if` statement executes a block only if the condition is true.",
                "xp_reward": 10,
                "explanation": ""
              },
              {
                "card_id": "b92574c3-5947-4eda-a0be-6616e6e14044",
                "type": "code",
                "content": "Write a program that checks if a number is positive or negative.",
                "xp_reward": 40,
                "explanation": "",
                "starter_code": "#include <stdio.h>\nint main() {\n    int num;\n    // check if num > 0\n    return 0;\n}",
                "test_cases": [
                  {
                    "input": "5",
                    "expected_output": "Positive"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          },
          {
            "topic_id": "9d6a6b24-0327-4f22-b35a-d84b016a3173",
            "title": "Loops in C",
            "content": "Repeat actions efficiently using for, while, and do-while loops.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "ee6ddd95-d35e-48ac-a15f-66610ab4532b",
                "type": "theory",
                "content": "Loops execute a block of code multiple times until a condition is false.",
                "xp_reward": 10,
                "explanation": ""
              },
              {
                "card_id": "25430ec3-f79c-4076-8cc1-92072ec2b6a8",
                "type": "code",
                "content": "Print numbers from 1 to 5 using a for loop.",
                "xp_reward": 40,
                "explanation": "",
                "starter_code": "#include <stdio.h>\nint main() {\n    // loop from 1 to 5\n    return 0;\n}",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "1 2 3 4 5"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          }
        ]
      },
      {
        "module_id": "ee22533a-eda3-4297-a6af-6b6b0300bc20",
        "title": "Module 4: Functions and Arrays",
        "order": 4,
        "topics": [
          {
            "topic_id": "2fb06779-17b0-4327-aa5e-999759408264",
            "title": "Functions in C",
            "content": "Organize your code into reusable blocks using functions.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "2df2f059-b76c-4235-8f6c-24540579b4fd",
                "type": "theory",
                "content": "Functions in C allow code reuse and better organization. They can return values or be void.",
                "xp_reward": 10,
                "explanation": ""
              },
              {
                "card_id": "afafee35-df7e-4d88-b620-5bb719285b57",
                "type": "code",
                "content": "Write a function `add()` that takes two integers and returns their sum.",
                "xp_reward": 30,
                "explanation": "",
                "starter_code": "int add(int a, int b) {\n    // return sum\n}",
                "test_cases": [
                  {
                    "input": "2 3",
                    "expected_output": "5"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          },
          {
            "topic_id": "67986947-4345-4b96-9bd9-b61f4cbd2f48",
            "title": "Arrays in C",
            "content": "Store multiple values in a single variable using arrays.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "514773ac-a08b-45fa-975d-718e7cf08661",
                "type": "theory",
                "content": "Arrays are fixed-size collections of elements of the same data type.",
                "xp_reward": 10,
                "explanation": ""
              },
              {
                "card_id": "90394f36-d4c6-4bc8-a055-e77d606f6789",
                "type": "fill-in-blank",
                "content": "The first element of an array has index ____.",
                "xp_reward": 10,
                "explanation": "",
                "blanks": [
                  "blank"
                ],
                "correct_answers": [
                  "0"
                ]
              }
            ]
          }
        ]
      },
      {
        "module_id": "325dec11-868e-4222-ba00-5af929a3d4ca",
        "title": "Module 5: Pointers and Memory Basics",
        "order": 5,
        "topics": [
          {
            "topic_id": "23393eb3-3de6-47d0-b826-7ab69c57e73c",
            "title": "Introduction to Pointers",
            "content": "Understand how to work directly with memory using pointers.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "a525a856-c1b7-424d-837f-ae9e8d020923",
                "type": "theory",
                "content": "A pointer is a variable that stores the address of another variable.",
                "xp_reward": 10,
                "explanation": ""
              },
              {
                "card_id": "bf6f38f0-bedc-4ab1-9cb5-97ef51d44d1a",
                "type": "code",
                "content": "Write a program that prints the address of a variable using a pointer.",
                "xp_reward": 40,
                "explanation": "",
                "starter_code": "#include <stdio.h>\nint main() {\n    int a = 10;\n    // print address of a\n    return 0;\n}",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "Address: <some_value>"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          },
          {
            "topic_id": "dd001050-610e-470e-a5e5-a9f92d322edc",
            "title": "Dynamic Memory Allocation",
            "content": "Learn to allocate and free memory at runtime using malloc() and free().",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "6c16caef-349f-4488-ab15-1bff9f170140",
                "type": "theory",
                "content": "Functions like malloc(), calloc(), and free() from <stdlib.h> manage dynamic memory.",
                "xp_reward": 10,
                "explanation": ""
              },
              {
                "card_id": "cf462751-f2b7-49a5-a59a-d15ce382fb14",
                "type": "fill-in-blank",
                "content": "Function used to release allocated memory is ____.",
                "xp_reward": 10,
                "explanation": "",
                "blanks": [
                  "blank"
                ],
                "correct_answers": [
                  "free"
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "_id": "68f8f8d6264227b77d6caf8c",
    "title": "Data Structures for Beginners",
    "description": "Learn the fundamentals of data structures step by step with Python. This course covers arrays, lists, stacks, queues, linked lists, trees, and basic algorithms using hands-on examples, quizzes, and code challenges.",
    "slug": "data-structures-for-beginners",
    "xp_reward": 1500,
    "created_at": "2025-10-22T15:31:34.051000",
    "updated_at": "2025-10-22T15:31:34.051000",
    "modules": [
      {
        "module_id": "93c53e10-3f06-4e05-baf2-1de48418d188",
        "title": "Module 1: Introduction to Data Structures",
        "order": 1,
        "topics": [
          {
            "topic_id": "02d05784-27a8-4ae7-94b9-f7d0d9be99da",
            "title": "What are Data Structures?",
            "content": "Understand the definition, types, and importance of data structures in programming and problem-solving.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "895a39a2-dc82-48a4-a360-80d899b69523",
                "type": "theory",
                "content": "A data structure is a way to organize and store data so that it can be accessed and modified efficiently. Common data structures include arrays, lists, stacks, queues, linked lists, trees, and graphs. Choosing the right data structure can significantly affect the performance of your program.",
                "xp_reward": 10,
                "explanation": "Data structures allow efficient data storage, access, and management."
              },
              {
                "card_id": "ec4eb38c-4ef0-48ac-9a57-cf2fc904d46a",
                "type": "theory",
                "content": "Data structures are classified into two types: Primitive (integers, floats, booleans, characters) and Non-Primitive (arrays, lists, stacks, queues, trees, graphs). Primitive data types are the building blocks for non-primitive structures.",
                "xp_reward": 10,
                "explanation": "Non-primitive structures are more complex and support efficient algorithms."
              },
              {
                "card_id": "1a042b4a-c493-4883-b884-3b32c18584ea",
                "type": "mcq",
                "content": "Which of the following is a non-linear data structure?",
                "xp_reward": 10,
                "explanation": "A tree is hierarchical and non-linear, unlike arrays or stacks which are linear.",
                "choices": [
                  "Array",
                  "Linked List",
                  "Tree",
                  "Stack"
                ],
                "correct_choice_index": 2
              },
              {
                "card_id": "33fa48fc-3063-49c2-bd63-00ed02479d52",
                "type": "code",
                "content": "Write a Python function that prints all elements of a list one by one.",
                "xp_reward": 30,
                "explanation": "Iterate through the list using a for loop and print each element.",
                "starter_code": "def print_list_elements(lst):\n    # Your code here\n    pass",
                "test_cases": [
                  {
                    "input": "[1, 2, 3]",
                    "expected_output": "1 2 3"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "69013a7e-04f1-46a9-90d3-005b58c1e5bb",
                "type": "fill-in-blank",
                "content": "A data structure that stores elements sequentially is called a _____.",
                "xp_reward": 10,
                "explanation": "Linear structures store elements one after another.",
                "correct_answers": [
                  "linear"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          },
          {
            "topic_id": "9c64ea06-e0db-469c-8221-b1c0929c80a6",
            "title": "Time and Space Complexity",
            "content": "Learn how to analyze algorithm efficiency in terms of time and memory usage.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "df8c6652-c483-4a64-927b-da784eee8ef9",
                "type": "theory",
                "content": "Time complexity measures the amount of computational time an algorithm takes relative to input size. Common notations include O(1), O(n), O(log n), and O(n^2). O(1) is constant time, O(n) is linear time, O(log n) is logarithmic, and O(n^2) is quadratic.",
                "xp_reward": 10,
                "explanation": "Time complexity helps predict performance on large inputs."
              },
              {
                "card_id": "045bd901-018c-4ef5-a69f-2b91db80bf43",
                "type": "theory",
                "content": "Space complexity refers to the amount of memory an algorithm uses relative to input size. Efficient algorithms minimize both time and space usage.",
                "xp_reward": 10,
                "explanation": "Space-efficient algorithms help reduce memory consumption."
              },
              {
                "card_id": "05e3fbc4-13a1-418a-b82a-3a001b2e2deb",
                "type": "mcq",
                "content": "What is the time complexity of accessing an element in a Python list by index?",
                "xp_reward": 10,
                "explanation": "Lists allow direct access to elements by index, giving constant time complexity O(1).",
                "choices": [
                  "O(n)",
                  "O(1)",
                  "O(log n)",
                  "O(n log n)"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "5c90dedd-9ee0-4acc-8031-c6f915eaca7e",
                "type": "code",
                "content": "Write a function to calculate the sum of elements in a list and explain its time complexity.",
                "xp_reward": 30,
                "explanation": "Iterating through the list once gives O(n) time complexity.",
                "starter_code": "def list_sum(lst):\n    # Your code here\n    pass",
                "test_cases": [
                  {
                    "input": "[1,2,3]",
                    "expected_output": "6"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "5b7f7326-ed22-4c91-98fd-da83c85bcddf",
                "type": "fill-in-blank",
                "content": "Big O notation describes the _____ case performance of an algorithm.",
                "xp_reward": 10,
                "explanation": "Big O is used to represent worst-case efficiency.",
                "correct_answers": [
                  "worst"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          }
        ]
      },
      {
        "module_id": "2f9cdd2c-bd51-4845-bd10-c5dd842805c0",
        "title": "Module 2: Arrays and Lists",
        "order": 2,
        "topics": [
          {
            "topic_id": "e28cdef2-f308-4b61-a4b6-d9fd667e6279",
            "title": "Arrays",
            "content": "Learn about arrays and how to work with them in Python using lists.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "022a9514-d593-461d-befc-147c591c05a3",
                "type": "theory",
                "content": "An array stores elements of the same type in contiguous memory locations. Python lists behave like dynamic arrays and allow different data types. Arrays provide fast access and iteration but resizing may take time.",
                "xp_reward": 10,
                "explanation": "Arrays are suitable for scenarios requiring index-based access."
              },
              {
                "card_id": "936f6831-d274-4998-b43d-b6153d7e0dfe",
                "type": "code",
                "content": "Write a Python function to reverse a list without using the built-in reverse() method.",
                "xp_reward": 30,
                "explanation": "Use a for loop or slicing to reverse elements manually.",
                "starter_code": "def reverse_list(lst):\n    # Your code here\n    pass",
                "test_cases": [
                  {
                    "input": "[1,2,3]",
                    "expected_output": "[3,2,1]"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "8fadc3a8-240d-41c2-91f8-f78b60851f47",
                "type": "mcq",
                "content": "What is the index of the first element in a Python list?",
                "xp_reward": 10,
                "explanation": "Python lists are 0-indexed.",
                "choices": [
                  "0",
                  "1",
                  "-1",
                  "None"
                ],
                "correct_choice_index": 0
              },
              {
                "card_id": "dd9a82b0-0ea2-403a-8316-2640bfe15c3c",
                "type": "fill-in-blank",
                "content": "The process of arranging elements in a specific order in an array is called _____.",
                "xp_reward": 10,
                "explanation": "Sorting organizes data ascendingly or descendingly.",
                "correct_answers": [
                  "sorting"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          },
          {
            "topic_id": "cba86e67-9b6e-4e32-bb5e-12afb6184176",
            "title": "Stacks",
            "content": "Understand the stack data structure and its Last-In-First-Out (LIFO) principle.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "41052aff-ab79-4d82-8fd5-4c27a4b2eef2",
                "type": "theory",
                "content": "A stack is a linear data structure that follows the LIFO principle. The last element added is the first to be removed. Common operations include push (insert), pop (remove), and peek (top element). Stacks are used in undo operations, expression evaluation, and function calls.",
                "xp_reward": 10,
                "explanation": "LIFO principle ensures the last item is processed first."
              },
              {
                "card_id": "a3b85af0-d671-42ce-ac4d-4f4651d06eb6",
                "type": "code",
                "content": "Implement a Stack class in Python with push, pop, and peek methods.",
                "xp_reward": 30,
                "explanation": "",
                "starter_code": "class Stack:\n    def __init__(self):\n        self.items = []\n    # Implement push, pop, peek",
                "test_cases": [],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "ad1e684e-c8d4-4a03-92b9-e294767e6709",
                "type": "fill-in-blank",
                "content": "Stacks follow the _____ principle.",
                "xp_reward": 10,
                "explanation": "Last-In-First-Out ensures the top element is accessed first.",
                "correct_answers": [
                  "LIFO"
                ],
                "blanks": [
                  "blank"
                ]
              },
              {
                "card_id": "1da69657-972e-4bcc-a23a-66e0cd716773",
                "type": "mcq",
                "content": "Which of these is a common use of stacks?",
                "xp_reward": 10,
                "explanation": "Undo operations rely on LIFO ordering, making stacks ideal.",
                "choices": [
                  "Task scheduling",
                  "Undo operations",
                  "Caching",
                  "Queue management"
                ],
                "correct_choice_index": 1
              }
            ]
          },
          {
            "topic_id": "4e361e6f-b24f-493e-b6d0-f8cf2f6288fd",
            "title": "Queues",
            "content": "Learn about queues and the First-In-First-Out (FIFO) principle.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "0bc368ba-69dd-4516-b74e-08b7d3fd4a08",
                "type": "theory",
                "content": "A queue is a linear structure that follows FIFO. Elements are added at the rear (enqueue) and removed from the front (dequeue). Queues are used in task scheduling, printer spooling, and breadth-first search in graphs.",
                "xp_reward": 10,
                "explanation": "FIFO ensures elements are processed in the order they arrive."
              },
              {
                "card_id": "a7b7ce86-10f6-4e35-9f6c-2814f21a16cc",
                "type": "code",
                "content": "Implement a Queue class in Python with enqueue and dequeue methods.",
                "xp_reward": 30,
                "explanation": "",
                "starter_code": "class Queue:\n    def __init__(self):\n        self.items = []\n    # Implement enqueue, dequeue",
                "test_cases": [],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "830b9936-61d5-40ac-92d1-55dc8dc3230f",
                "type": "fill-in-blank",
                "content": "Queues follow the _____ principle.",
                "xp_reward": 10,
                "explanation": "First-In-First-Out ensures processing order is maintained.",
                "correct_answers": [
                  "FIFO"
                ],
                "blanks": [
                  "blank"
                ]
              },
              {
                "card_id": "1e33e43a-aa21-4d7a-a176-ed04b01cf632",
                "type": "mcq",
                "content": "Which method adds an element to a queue?",
                "xp_reward": 10,
                "explanation": "enqueue adds elements to the rear of a queue.",
                "choices": [
                  "push",
                  "insert",
                  "enqueue",
                  "pop"
                ],
                "correct_choice_index": 2
              }
            ]
          }
        ]
      },
      {
        "module_id": "24cc2371-78ba-48f3-a21d-abaf399479db",
        "title": "Module 3: Linked Lists",
        "order": 3,
        "topics": [
          {
            "topic_id": "d5f9c6ae-3775-4b2c-94ae-fc5d4f67d0dc",
            "title": "Singly Linked Lists",
            "content": "Learn the structure and implementation of singly linked lists in Python.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "0dc74e9c-50f0-4711-9aa0-c0b08ad3407c",
                "type": "theory",
                "content": "A singly linked list consists of nodes where each node contains data and a pointer to the next node. The first node is called the head. Linked lists allow dynamic memory allocation and easy insertion or deletion compared to arrays.",
                "xp_reward": 10,
                "explanation": "Nodes are connected linearly, forming a chain of elements."
              },
              {
                "card_id": "0e335b30-7f0e-4052-a1e3-3f7194d359e4",
                "type": "code",
                "content": "Implement a Node class and a SinglyLinkedList class with insert and display methods.",
                "xp_reward": 30,
                "explanation": "",
                "starter_code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass SinglyLinkedList:\n    def __init__(self):\n        self.head = None\n    # Implement insert and display methods",
                "test_cases": [],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "c7bca371-88bb-42a7-b5a0-28cfceb7f537",
                "type": "mcq",
                "content": "What is the time complexity to access the nth element in a singly linked list?",
                "xp_reward": 10,
                "explanation": "Accessing requires traversing from the head, taking linear time.",
                "choices": [
                  "O(1)",
                  "O(n)",
                  "O(log n)",
                  "O(n^2)"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "5460c582-f668-4d78-83b3-c9ae50d8f143",
                "type": "fill-in-blank",
                "content": "Each element in a linked list is called a _____.",
                "xp_reward": 10,
                "explanation": "A node contains data and pointer(s) to other nodes.",
                "correct_answers": [
                  "node"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          },
          {
            "topic_id": "8d7013fb-6c77-4bf6-a7d7-68e387c5f816",
            "title": "Doubly Linked Lists",
            "content": "Understand doubly linked lists where nodes have two pointers.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "b11ed56f-495f-413f-8d27-9a497d83fb0c",
                "type": "theory",
                "content": "A doubly linked list has nodes with two pointers: one pointing to the next node and one to the previous node. This allows traversal in both directions. It is useful for implementing stacks, queues, and undo/redo operations.",
                "xp_reward": 10,
                "explanation": "Backward traversal is possible due to the previous pointer."
              },
              {
                "card_id": "5ba56d55-c140-4890-a1fd-12c7e074986b",
                "type": "code",
                "content": "Implement a DoublyLinkedList class with insert, display_forward, and display_backward methods.",
                "xp_reward": 30,
                "explanation": "",
                "starter_code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n        self.prev = None\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n    # Implement insert, display_forward, display_backward",
                "test_cases": [],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "a4efb440-b866-4c0b-863e-c75b7e455b87",
                "type": "mcq",
                "content": "Which pointer in a doubly linked list allows backward traversal?",
                "xp_reward": 10,
                "explanation": "The prev pointer stores reference to the previous node.",
                "choices": [
                  "next",
                  "prev",
                  "head",
                  "tail"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "1be7eec0-6ab1-4cba-bcad-a7bfc800bc77",
                "type": "fill-in-blank",
                "content": "In a doubly linked list, each node has _____ pointers.",
                "xp_reward": 10,
                "explanation": "Next and previous pointers enable bidirectional traversal.",
                "correct_answers": [
                  "two"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          }
        ]
      },
      {
        "module_id": "3c41952c-62f5-4f91-92c8-40fc32b5aebe",
        "title": "Module 4: Trees",
        "order": 4,
        "topics": [
          {
            "topic_id": "3ab6f2b3-56a6-4723-9f63-a737c48600a2",
            "title": "Binary Trees",
            "content": "Understand binary trees, nodes, root, and child relationships.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "bed1d09a-8773-4955-be04-bfaffa8e49d0",
                "type": "theory",
                "content": "A binary tree is a hierarchical structure with nodes having at most two children: left and right. The topmost node is the root. Binary trees are used in expression parsing, search operations, and priority queues.",
                "xp_reward": 10,
                "explanation": "Each node links to zero, one, or two child nodes."
              },
              {
                "card_id": "f764e466-76ca-4881-a5d5-4d919f0629f9",
                "type": "code",
                "content": "Implement a Node class and a BinaryTree class with insert and traversal methods (in-order).",
                "xp_reward": 30,
                "explanation": "",
                "starter_code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass BinaryTree:\n    def __init__(self):\n        self.root = None\n    # Implement insert and in_order_traversal",
                "test_cases": [],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "e0552998-68d1-4392-91e4-3a919cf657bb",
                "type": "mcq",
                "content": "What is the maximum number of children a node can have in a binary tree?",
                "xp_reward": 10,
                "explanation": "Binary tree nodes have at most two children.",
                "choices": [
                  "1",
                  "2",
                  "3",
                  "4"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "29bf784d-eb46-4af7-acff-2bc337950609",
                "type": "fill-in-blank",
                "content": "The topmost node of a tree is called the _____.",
                "xp_reward": 10,
                "explanation": "All other nodes descend from the root.",
                "correct_answers": [
                  "root"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          },
          {
            "topic_id": "5f98ae20-5b0b-438d-9993-580501392bf8",
            "title": "Binary Search Trees",
            "content": "Learn the properties and implementation of Binary Search Trees (BST).",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "db3b9cca-a51c-466a-93ac-2bb3e8bcae3a",
                "type": "theory",
                "content": "A Binary Search Tree (BST) is a binary tree where left child nodes are smaller than the parent and right child nodes are larger. BSTs allow fast searching, insertion, and deletion in O(log n) time on average.",
                "xp_reward": 10,
                "explanation": "Maintaining the BST property ensures efficient operations."
              },
              {
                "card_id": "d4825651-1fcd-4bfe-8505-a872f371ab05",
                "type": "code",
                "content": "Implement a BST insert method and in-order traversal to print elements in ascending order.",
                "xp_reward": 30,
                "explanation": "",
                "starter_code": "class BSTNode:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass BST:\n    def __init__(self):\n        self.root = None\n    # Implement insert and in_order_traversal",
                "test_cases": [],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "43c04dbb-86af-4380-b30a-4d8f2c68a65d",
                "type": "mcq",
                "content": "In a BST, where is a smaller value placed relative to a node?",
                "xp_reward": 10,
                "explanation": "Smaller values are placed as left child nodes.",
                "choices": [
                  "Left child",
                  "Right child",
                  "Parent",
                  "Root"
                ],
                "correct_choice_index": 0
              },
              {
                "card_id": "f7deda30-9c8d-493e-9216-033c52eb6113",
                "type": "fill-in-blank",
                "content": "In-order traversal of a BST gives elements in _____ order.",
                "xp_reward": 10,
                "explanation": "Visiting left, root, right gives sorted order.",
                "correct_answers": [
                  "ascending"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          }
        ]
      },
      {
        "module_id": "96e5ec18-f280-47b7-83d2-620beb95053b",
        "title": "Module 5: Basic Algorithms",
        "order": 5,
        "topics": [
          {
            "topic_id": "1c0ccdbf-ed30-42c1-b029-b9fc5585ae5d",
            "title": "Searching Algorithms",
            "content": "Learn linear search and binary search techniques.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "bae924ff-b058-4b9d-b475-bd4593b590ff",
                "type": "theory",
                "content": "Linear search checks each element one by one until a match is found. Its time complexity is O(n). Binary search works on sorted arrays and divides the search space in half each time, with O(log n) complexity.",
                "xp_reward": 10,
                "explanation": "Binary search is more efficient for large sorted datasets."
              },
              {
                "card_id": "d03d4516-0c9d-4e7c-b0b8-93032a5cd36a",
                "type": "code",
                "content": "Implement linear search and binary search functions in Python.",
                "xp_reward": 30,
                "explanation": "",
                "starter_code": "def linear_search(arr, target):\n    # Your code here\n    pass\n\ndef binary_search(arr, target):\n    # Your code here\n    pass",
                "test_cases": [],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "fcb322cf-a09c-46c1-b95e-cdc6ff54ce1f",
                "type": "mcq",
                "content": "Which search algorithm requires a sorted array?",
                "xp_reward": 10,
                "explanation": "Binary search only works efficiently on sorted data.",
                "choices": [
                  "Linear search",
                  "Binary search",
                  "Both",
                  "None"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "a656ffc9-0dde-4589-85ab-6fa777bf2a99",
                "type": "fill-in-blank",
                "content": "The time complexity of linear search is _____.",
                "xp_reward": 10,
                "explanation": "Linear search may examine each element once.",
                "correct_answers": [
                  "O(n)"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          },
          {
            "topic_id": "9b6a93fc-660b-43fc-8e2e-c28e2791a6e4",
            "title": "Sorting Algorithms",
            "content": "Learn bubble sort, selection sort, and insertion sort.",
            "xp_reward": 120,
            "cards": [
              {
                "card_id": "76d63d5c-2d66-4d25-9a7c-a05cb5c831ac",
                "type": "theory",
                "content": "Bubble sort repeatedly swaps adjacent elements if they are in the wrong order. Selection sort selects the minimum element from unsorted part and places it at the beginning. Insertion sort builds the sorted array one element at a time.",
                "xp_reward": 10,
                "explanation": "These are simple sorting algorithms suitable for beginners."
              },
              {
                "card_id": "19716eb8-055c-4401-a3e3-9237a97abce9",
                "type": "code",
                "content": "Implement bubble sort on a Python list.",
                "xp_reward": 30,
                "explanation": "",
                "starter_code": "def bubble_sort(lst):\n    # Your code here\n    pass",
                "test_cases": [],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "00276567-cb00-42d4-80e1-fd986c9bae7d",
                "type": "mcq",
                "content": "Which sorting algorithm repeatedly swaps adjacent elements?",
                "xp_reward": 10,
                "explanation": "Bubble sort swaps adjacent elements until the array is sorted.",
                "choices": [
                  "Selection Sort",
                  "Insertion Sort",
                  "Bubble Sort",
                  "Merge Sort"
                ],
                "correct_choice_index": 2
              },
              {
                "card_id": "03ab44ba-1e19-4027-9fb8-14c910ba5b46",
                "type": "fill-in-blank",
                "content": "In selection sort, we select the _____ element from the unsorted array each time.",
                "xp_reward": 10,
                "explanation": "Minimum is placed at the beginning of sorted section.",
                "correct_answers": [
                  "minimum"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "_id": "68f90112264227b77d6caf8d",
    "title": "Intermediate DSA with Python",
    "description": "Deep dive into arrays, strings, linked lists, stacks, queues, trees, heaps, graphs, hashing, recursion, dynamic programming, and advanced problem-solving techniques in Python.",
    "slug": "intermediate-dsa-with-python",
    "xp_reward": 500,
    "created_at": "2025-10-22T16:06:42.147000",
    "updated_at": "2025-10-22T16:06:42.147000",
    "modules": [
      {
        "module_id": "6ec0824a-cec2-42b3-bd55-89e6258d4324",
        "title": "Module 1: Advanced Arrays & Strings",
        "order": 1,
        "topics": [
          {
            "topic_id": "5892aa1b-1496-44e4-bca3-e4bd109a90d7",
            "title": "Multidimensional Arrays",
            "content": "Learn how to work with 2D and 3D arrays, including initialization, traversal, and common operations.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "6ed61e45-c7b2-4eca-a66f-f0a4ec5d27ac",
                "type": "theory",
                "content": "Multidimensional arrays are arrays of arrays. In Python, they can be implemented using nested lists. They allow storing tabular data such as matrices and grids. Common operations include accessing elements using multiple indices, traversing with nested loops, and performing row/column operations.",
                "xp_reward": 15,
                "explanation": "Example: To access the element at row 2, column 3, use `matrix[1][2]`."
              },
              {
                "card_id": "d3cfbe72-e194-4ed0-b857-ce611197832e",
                "type": "code",
                "content": "Create a 3x3 matrix initialized with zeros and print it row-wise.",
                "xp_reward": 20,
                "explanation": "",
                "starter_code": "def create_matrix():\n    # Return 3x3 matrix of zeros\n    pass",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "[[0,0,0],[0,0,0],[0,0,0]]"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "132387b1-2c77-46a3-9226-aa859a676841",
                "type": "mcq",
                "content": "Which of the following is a correct way to access the first row of a 2D list `matrix`?",
                "xp_reward": 10,
                "explanation": "matrix[0] returns the first row as a list.",
                "choices": [
                  "matrix[0]",
                  "matrix[1]",
                  "matrix[:0]",
                  "matrix[0][0]"
                ],
                "correct_choice_index": 0
              },
              {
                "card_id": "7dea20ff-8eb7-4f9c-b311-638cbe0ba512",
                "type": "fill-in-blank",
                "content": "In a 2D array, the number of indices required to access an element is _____.",
                "xp_reward": 10,
                "explanation": "Two indices represent row and column.",
                "correct_answers": [
                  "2"
                ],
                "blanks": [
                  "blank"
                ]
              },
              {
                "card_id": "509dc88e-9b8a-420b-b8eb-52b001140d6b",
                "type": "theory",
                "content": "Operations such as row sum, column sum, and matrix transpose are common with 2D arrays. Nested loops are used for traversal, and Python list comprehensions can simplify these operations.",
                "xp_reward": 15,
                "explanation": "Transpose example: `[[matrix[j][i] for j in range(n)] for i in range(m)]`."
              },
              {
                "card_id": "4d043e54-d5c3-412c-9a20-c4da4999bd5b",
                "type": "code",
                "content": "Transpose a given 2x3 matrix.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def transpose_matrix(matrix):\n    # Return transposed matrix\n    pass",
                "test_cases": [
                  {
                    "input": "[[1,2,3],[4,5,6]]",
                    "expected_output": "[[1,4],[2,5],[3,6]]"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "3b26d1f8-d2aa-4e57-804e-2ec1b44bf6cd",
                "type": "theory",
                "content": "Multidimensional arrays are essential for image processing, dynamic programming grids, and game boards.",
                "xp_reward": 15,
                "explanation": "Each element can represent pixels, state values, or positions."
              }
            ]
          },
          {
            "topic_id": "d85a3bb7-8452-4d63-bd46-0f8831d9b50d",
            "title": "Sliding Window & Two-Pointer Techniques",
            "content": "Learn efficient methods to solve subarray problems using sliding window and two-pointer approaches.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "7f701698-e2c4-41c5-b9c7-6319c5eebeb5",
                "type": "theory",
                "content": "The sliding window technique reduces time complexity for problems involving contiguous subarrays or substrings. A fixed or variable-size window slides over the array to maintain the required condition. The two-pointer technique uses two indices moving through the array to solve problems efficiently, often used in sorting or sum-related problems.",
                "xp_reward": 15,
                "explanation": "Example: Find maximum sum of subarray of size k using a sliding window."
              },
              {
                "card_id": "73115b63-d842-41a1-a4e9-40f74e88d741",
                "type": "code",
                "content": "Find the maximum sum of any subarray of size 3 in a list.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def max_subarray_sum(arr, k):\n    # Return maximum sum of subarray of size k\n    pass",
                "test_cases": [
                  {
                    "input": "[2,1,5,1,3,2],3",
                    "expected_output": "9"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "c7187da2-21c9-4091-910f-0b5e914b6406",
                "type": "mcq",
                "content": "Sliding window technique is most suitable for problems with:",
                "xp_reward": 10,
                "explanation": "It works efficiently for contiguous sequences.",
                "choices": [
                  "Non-contiguous elements",
                  "Contiguous subarrays/substrings",
                  "Graphs",
                  "Trees"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "11069275-f6d5-4e77-ab1d-6d55bcd084ce",
                "type": "fill-in-blank",
                "content": "The two-pointer technique usually works on _____ arrays.",
                "xp_reward": 10,
                "explanation": "Sorting ensures the pointer movement can satisfy conditions efficiently.",
                "correct_answers": [
                  "sorted"
                ],
                "blanks": [
                  "blank"
                ]
              },
              {
                "card_id": "fb154f29-2ceb-48a1-9ea7-bf975698f075",
                "type": "theory",
                "content": "Both techniques reduce nested loops and improve performance from O(n^2) to O(n) for many problems.",
                "xp_reward": 15,
                "explanation": "Key for medium and advanced DSA problems."
              }
            ]
          },
          {
            "topic_id": "f2a66ed5-dba5-43ab-adcd-0494a0f35b7c",
            "title": "Prefix Sums & Subarray Problems",
            "content": "Learn how prefix sums help in efficiently calculating subarray sums and solving related problems.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "1edbeccd-ef89-4b25-8ece-220dc6c6a273",
                "type": "theory",
                "content": "Prefix sum arrays store the cumulative sum of elements. To find the sum of any subarray from index i to j, we can use prefix[j] - prefix[i-1]. This reduces repeated summation and improves time complexity from O(n^2) to O(n).",
                "xp_reward": 15,
                "explanation": "Common applications include range sum queries and solving subarray sum problems."
              },
              {
                "card_id": "aeca2866-cd97-4ca0-a0e1-3e67ad1f5486",
                "type": "code",
                "content": "Given a list, build its prefix sum array.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def prefix_sum(arr):\n    # Return prefix sum array\n    pass",
                "test_cases": [
                  {
                    "input": "[1,2,3,4]",
                    "expected_output": "[1,3,6,10]"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "7b9a7660-c83c-4547-9dcf-2d1175930661",
                "type": "mcq",
                "content": "Prefix sum array is used to:",
                "xp_reward": 10,
                "explanation": "Prefix sums store cumulative totals.",
                "choices": [
                  "Store elements in reverse",
                  "Store cumulative sums",
                  "Sort array",
                  "Find duplicates"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "d80dcdd1-b872-4f0a-b427-9170935505ad",
                "type": "fill-in-blank",
                "content": "To get the sum of subarray arr[i..j], use _____ formula with prefix sum array.",
                "xp_reward": 10,
                "explanation": "It allows O(1) subarray sum queries after prefix array construction.",
                "correct_answers": [
                  "prefix[j]-prefix[i-1]"
                ],
                "blanks": [
                  "blank"
                ]
              },
              {
                "card_id": "af3f5867-41ea-4451-886b-f824f2f63bde",
                "type": "theory",
                "content": "Prefix sums also help in solving problems like number of subarrays with given sum, cumulative frequency counts, and difference arrays.",
                "xp_reward": 15,
                "explanation": "Efficient technique widely used in competitive programming."
              }
            ]
          },
          {
            "topic_id": "088f995f-91eb-4b19-9032-ba75a4dd527e",
            "title": "String Manipulation & Pattern Matching",
            "content": "Learn advanced string operations, searching patterns, and matching techniques.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "991020df-95d4-4f61-ada6-d01a6e39ee08",
                "type": "theory",
                "content": "Strings in Python are immutable sequences of characters. Common manipulations include slicing, concatenation, reversing, and using built-in functions. Pattern matching can be done with loops or regular expressions. Efficient searching uses KMP, Rabin-Karp, or built-in functions for substrings.",
                "xp_reward": 15,
                "explanation": "Example: `s[::-1]` reverses a string; `re.search()` matches patterns."
              },
              {
                "card_id": "1bdbb9e8-2b7f-4136-b532-c803a0d3d430",
                "type": "code",
                "content": "Check if a string is a palindrome.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def is_palindrome(s):\n    # Return True if palindrome else False\n    pass",
                "test_cases": [
                  {
                    "input": "'racecar'",
                    "expected_output": "True"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "7adc70ad-aaec-40ee-8487-506ebd1d4932",
                "type": "mcq",
                "content": "Which of the following is an immutable sequence in Python?",
                "xp_reward": 10,
                "explanation": "Strings cannot be changed after creation.",
                "choices": [
                  "List",
                  "Dictionary",
                  "String",
                  "Set"
                ],
                "correct_choice_index": 2
              },
              {
                "card_id": "7d2db2b9-1188-4ddb-8b8d-5c5bfb263345",
                "type": "fill-in-blank",
                "content": "To reverse a string `s` in Python, use _____ slicing.",
                "xp_reward": 10,
                "explanation": "Negative step slicing reverses the sequence.",
                "correct_answers": [
                  "s[::-1]"
                ],
                "blanks": [
                  "blank"
                ]
              },
              {
                "card_id": "f8d3970a-1540-4225-939b-6d600d57d6d3",
                "type": "theory",
                "content": "Pattern matching is essential in text processing, searching algorithms, and real-world applications like DNA sequencing, log analysis, and code editors.",
                "xp_reward": 15,
                "explanation": "Efficient string handling is critical for intermediate DSA problems."
              }
            ]
          }
        ]
      },
      {
        "module_id": "b40042d0-57ec-40e7-8298-d15f42336f03",
        "title": "Module 2: Linked Lists",
        "order": 2,
        "topics": [
          {
            "topic_id": "4e051464-fdce-44f8-921c-5a3be656c1d5",
            "title": "Singly Linked List Basics",
            "content": "Learn the fundamentals of singly linked lists, including nodes, pointers, and traversal.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "9f51c869-4ea9-42a5-b9e9-b1b533b7b49b",
                "type": "theory",
                "content": "A singly linked list is a sequence of nodes where each node contains data and a pointer to the next node. Unlike arrays, linked lists provide dynamic memory allocation and efficient insertion/deletion at any position.",
                "xp_reward": 15,
                "explanation": "Traversal is done by starting from the head node and following the `next` pointers until reaching `None`."
              },
              {
                "card_id": "42b95781-b1f6-417c-bcc4-f1bf6aa4bd80",
                "type": "code",
                "content": "Create a singly linked list with nodes containing 1, 2, 3 and print values.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def print_list(self):\n        # Print linked list values\n        pass",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "1 2 3"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "9fa640c3-8ea6-43b7-967a-1371259711e6",
                "type": "mcq",
                "content": "In a singly linked list, each node contains:",
                "xp_reward": 10,
                "explanation": "Each node has data and a pointer to the next node.",
                "choices": [
                  "Data only",
                  "Next pointer only",
                  "Data and next pointer",
                  "Data and previous pointer"
                ],
                "correct_choice_index": 2
              },
              {
                "card_id": "9da27ab1-2356-4683-b7fd-ef2a235c8438",
                "type": "fill-in-blank",
                "content": "The first node of a linked list is called the _____.",
                "xp_reward": 10,
                "explanation": "Head stores the starting reference of the list.",
                "correct_answers": [
                  "head"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          },
          {
            "topic_id": "d0143276-7b9b-47a2-8d59-9d3bb4b5faab",
            "title": "Insertion and Deletion in Singly Linked List",
            "content": "Learn how to insert and delete nodes at head, tail, and specific positions.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "27eadbc4-f2b6-44d3-bf09-0c25c20b5e62",
                "type": "theory",
                "content": "Insertion can be done at the beginning (head), end (tail), or any specific position. Deletion also requires updating the previous node's next pointer. These operations are efficient, taking O(1) time for head insertion and O(n) for arbitrary positions.",
                "xp_reward": 15,
                "explanation": "Edge cases include empty list or single-node list."
              },
              {
                "card_id": "3ec769b6-ce49-4ecf-8e7d-dc2d2daf14b5",
                "type": "code",
                "content": "Insert 4 at the end of a linked list and print the list.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def insert_end(self, data):\n    # Add node with data at the end\n    pass",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "1 2 3 4"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "75e3e0b0-db0b-4214-83b2-0b88af2fbb7d",
                "type": "code",
                "content": "Delete node with value 2 and print the list.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def delete_node(self, key):\n    # Delete node containing key\n    pass",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "1 3 4"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "77b745b1-b4f3-42b1-9f34-11de3898518c",
                "type": "mcq",
                "content": "Time complexity to insert at the head of a singly linked list is:",
                "xp_reward": 10,
                "explanation": "Head insertion takes constant time.",
                "choices": [
                  "O(n)",
                  "O(1)",
                  "O(log n)",
                  "O(n^2)"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "3751bbb7-d22a-4cf1-8446-4070c2188c3a",
                "type": "fill-in-blank",
                "content": "Deleting a node in a singly linked list requires updating the ____ of the previous node.",
                "xp_reward": 10,
                "explanation": "To bypass the deleted node and maintain list continuity.",
                "correct_answers": [
                  "next pointer"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          },
          {
            "topic_id": "3d316b64-ae9e-45c4-b031-932b2abd6577",
            "title": "Doubly Linked List",
            "content": "Learn doubly linked lists which contain pointers to both next and previous nodes.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "33d9425c-d7fa-4f9e-abed-f35084af2e0e",
                "type": "theory",
                "content": "A doubly linked list has nodes containing data, next pointer, and previous pointer. This allows traversal in both directions. Insertion and deletion are easier at both ends and also faster at arbitrary positions compared to singly linked lists.",
                "xp_reward": 15,
                "explanation": "Memory usage is slightly higher due to extra pointer."
              },
              {
                "card_id": "5a16ee6b-b591-4f67-ae1a-d0398abb5651",
                "type": "code",
                "content": "Create a doubly linked list with nodes 1,2,3 and traverse forward and backward.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "class DNode:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n        self.prev = None\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def traverse_forward(self):\n        # Print forward\n        pass\n\n    def traverse_backward(self):\n        # Print backward\n        pass",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "Forward: 1 2 3, Backward: 3 2 1"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "2b13a588-2cf7-48ef-8296-0727ecc04963",
                "type": "mcq",
                "content": "Advantage of doubly linked list over singly linked list is:",
                "xp_reward": 10,
                "explanation": "Doubly linked list allows traversal in both directions.",
                "choices": [
                  "Less memory usage",
                  "Two-way traversal",
                  "Simpler implementation",
                  "Faster head insertion"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "0f0e0af8-5a31-496b-8628-067492a7b12c",
                "type": "fill-in-blank",
                "content": "In a doubly linked list, each node has ____ pointers.",
                "xp_reward": 10,
                "explanation": "Next and previous pointers.",
                "correct_answers": [
                  "2"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          },
          {
            "topic_id": "3c922da8-5893-4998-b4ca-f7e3e1deec30",
            "title": "Circular Linked List",
            "content": "Learn circular linked lists where the last node points back to the head.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "101e50eb-e8b6-464c-a192-f0f4cb93c644",
                "type": "theory",
                "content": "In a circular linked list, the last node points back to the head node, forming a loop. It can be singly or doubly linked. Useful in scenarios like round-robin scheduling or continuous data buffering.",
                "xp_reward": 15,
                "explanation": "Traversal requires care to stop when you reach the head again."
              },
              {
                "card_id": "f8902c9f-7e20-4e62-8722-42c190408454",
                "type": "code",
                "content": "Create a circular singly linked list with nodes 1,2,3 and traverse 2 cycles.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "class CNode:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass CircularLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def traverse(self, cycles):\n        # Traverse the list for given cycles\n        pass",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "1 2 3 1 2 3"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "e87cbd48-5cb7-4a31-9e55-923142183a2d",
                "type": "mcq",
                "content": "Circular linked list is most useful when:",
                "xp_reward": 10,
                "explanation": "It allows continuous looping through the nodes.",
                "choices": [
                  "We need a fixed-size list",
                  "We need continuous looping",
                  "We need backward traversal only",
                  "Memory must be minimal"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "e6df809b-d1f6-4f39-8ca2-fbe57d906886",
                "type": "fill-in-blank",
                "content": "In a circular linked list, the last node points to _____.",
                "xp_reward": 10,
                "explanation": "Forming a loop for circular traversal.",
                "correct_answers": [
                  "head"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          },
          {
            "topic_id": "8bbab0b1-45c3-4be6-82c7-c6dfc8a0382f",
            "title": "Fast & Slow Pointer Techniques",
            "content": "Learn two-pointer technique to detect cycles, find middle node, and solve advanced problems.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "b987a161-301b-4162-b4ac-14695e4593af",
                "type": "theory",
                "content": "Fast and slow pointers (tortoise and hare) are used to solve linked list problems efficiently. Slow pointer moves one step at a time, fast moves two. This can detect cycles (Floyd’s cycle detection), find middle node, or detect loop starting node.",
                "xp_reward": 15,
                "explanation": "If fast meets slow, a cycle exists. Middle node is found when fast reaches the end."
              },
              {
                "card_id": "7fcb1ba1-4315-4f64-afa7-af22d35e90ce",
                "type": "code",
                "content": "Detect cycle in a linked list using fast and slow pointers.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def has_cycle(head):\n    # Return True if cycle exists else False\n    pass",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "True"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "eb56e46f-5406-4fd3-b0e0-45786ec28b02",
                "type": "code",
                "content": "Find the middle node of a linked list using fast and slow pointers.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def find_middle(head):\n    # Return middle node value\n    pass",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "2"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "3dd4c0b9-5205-444f-ab25-cf456289233b",
                "type": "mcq",
                "content": "Fast and slow pointer technique is primarily used to:",
                "xp_reward": 10,
                "explanation": "This technique is widely used in intermediate linked list problems.",
                "choices": [
                  "Sort linked lists",
                  "Detect cycles and find middle",
                  "Insert nodes",
                  "Delete nodes"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "ec1dec8c-a957-472d-9e43-9f557c873934",
                "type": "fill-in-blank",
                "content": "If fast and slow pointers meet in a linked list, it indicates a _____.",
                "xp_reward": 10,
                "explanation": "Meeting point confirms loop existence.",
                "correct_answers": [
                  "cycle"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          }
        ]
      },
      {
        "module_id": "32e741f4-c50b-436a-a6ef-10c500500fef",
        "title": "Module 3: Stacks & Queues",
        "order": 3,
        "topics": [
          {
            "topic_id": "38cce617-38a2-45c5-98a5-9d802eb90e0c",
            "title": "Stacks: Basics and Implementation",
            "content": "Learn the fundamentals of stacks, LIFO principle, and how to implement using arrays and linked lists.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "5973f31f-c1f5-4ca7-b99d-ecbebddcac52",
                "type": "theory",
                "content": "A stack is a linear data structure following Last-In-First-Out (LIFO) principle. The last element added is the first to be removed. Stacks are used in function call management, expression evaluation, undo mechanisms, and backtracking problems.",
                "xp_reward": 15,
                "explanation": "Operations include push (insert), pop (remove), and peek (top element)."
              },
              {
                "card_id": "4840691f-ce77-4d8e-890f-b669a1a91767",
                "type": "code",
                "content": "Implement a stack using a Python list and perform push and pop operations.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "class Stack:\n    def __init__(self):\n        self.items = []\n\n    def push(self, item):\n        pass\n\n    def pop(self):\n        pass\n\n    def peek(self):\n        pass\n\n    def is_empty(self):\n        pass",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "Push: 10, 20; Pop: 20"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "059c1516-15ff-4c0a-9ca6-61acc1f83e0b",
                "type": "mcq",
                "content": "Which operation in a stack returns the last inserted element without removing it?",
                "xp_reward": 10,
                "explanation": "Peek returns the top element without deletion.",
                "choices": [
                  "Push",
                  "Pop",
                  "Peek",
                  "Insert"
                ],
                "correct_choice_index": 2
              },
              {
                "card_id": "10f32d0e-70df-4276-9b64-4f5c49e0048a",
                "type": "fill-in-blank",
                "content": "Stack follows the _____ principle.",
                "xp_reward": 10,
                "explanation": "Last-In-First-Out is the key property.",
                "correct_answers": [
                  "LIFO"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          },
          {
            "topic_id": "a91771c0-926c-4118-bed1-a1ceae3bf3a0",
            "title": "Stack Applications",
            "content": "Explore common applications like expression evaluation, balanced parentheses, and backtracking.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "a613e0db-1c74-49a6-8def-fd398a459cd8",
                "type": "theory",
                "content": "Stacks are widely used for parsing expressions (infix, postfix, prefix), evaluating mathematical expressions, implementing undo-redo features, and solving backtracking problems like maze navigation and N-Queens problem.",
                "xp_reward": 15,
                "explanation": "Balanced parentheses checking is a classic stack problem."
              },
              {
                "card_id": "8a95f848-2c4e-4036-8261-8058e04c3725",
                "type": "code",
                "content": "Check if an expression with parentheses is balanced using a stack.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def is_balanced(expression):\n    # Return True if balanced else False\n    pass",
                "test_cases": [
                  {
                    "input": "([]{})",
                    "expected_output": "True"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "318d4c4c-bfeb-4344-9478-69e9d757b778",
                "type": "mcq",
                "content": "Stack is used in which of the following?",
                "xp_reward": 10,
                "explanation": "Expression evaluation is a primary use-case for stacks.",
                "choices": [
                  "Queue management",
                  "Expression evaluation",
                  "Binary Search",
                  "Sorting arrays"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "135fb9ce-024f-427a-bbc9-b03d8480976c",
                "type": "fill-in-blank",
                "content": "In backtracking problems, stack is used to store _____ states.",
                "xp_reward": 10,
                "explanation": "Stacks help restore previous states efficiently.",
                "correct_answers": [
                  "intermediate"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          },
          {
            "topic_id": "2ddc4bc6-1e45-44f0-a692-2b1683d098fa",
            "title": "Queues: Basics and Implementation",
            "content": "Understand queues, FIFO principle, and implementations using arrays and linked lists.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "24c80c99-584d-483f-97cb-539376826a55",
                "type": "theory",
                "content": "A queue is a linear data structure following First-In-First-Out (FIFO) principle. The first element added is the first to be removed. Queues are used in CPU scheduling, order processing, and breadth-first search in graphs.",
                "xp_reward": 15,
                "explanation": "Operations include enqueue (insert), dequeue (remove), and front/peek (first element)."
              },
              {
                "card_id": "ed057830-a102-49c5-949d-e32c21bd850e",
                "type": "code",
                "content": "Implement a queue using a Python list and perform enqueue and dequeue operations.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "class Queue:\n    def __init__(self):\n        self.items = []\n\n    def enqueue(self, item):\n        pass\n\n    def dequeue(self):\n        pass\n\n    def front(self):\n        pass\n\n    def is_empty(self):\n        pass",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "Enqueue: 10, 20; Dequeue: 10"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "e0bf4f9e-ac95-4941-a8d2-74432c6aa081",
                "type": "mcq",
                "content": "Which principle does a queue follow?",
                "xp_reward": 10,
                "explanation": "First-In-First-Out is the defining property of a queue.",
                "choices": [
                  "LIFO",
                  "FIFO",
                  "Random",
                  "Priority-based"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "6addede5-ff19-4eca-bb80-dd74003340ec",
                "type": "fill-in-blank",
                "content": "The first element inserted in a queue is called the _____.",
                "xp_reward": 10,
                "explanation": "Front always points to the first element.",
                "correct_answers": [
                  "front"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          },
          {
            "topic_id": "fbc05449-1634-4815-b18e-e4ec82a9f831",
            "title": "Circular Queue and Deque",
            "content": "Learn circular queues and double-ended queues (deque) for efficient insertion and deletion.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "3f6530e8-88cf-4440-b4c3-f9132d33aa64",
                "type": "theory",
                "content": "A circular queue allows efficient use of space by connecting the end of the queue back to the front. A deque (double-ended queue) allows insertion and deletion from both ends. Deques are used in sliding window problems and task scheduling.",
                "xp_reward": 15,
                "explanation": "Circular queues prevent wasted memory when the queue is implemented using arrays."
              },
              {
                "card_id": "17fff212-ac8b-4c1a-95a2-bc7c307740e3",
                "type": "code",
                "content": "Implement a circular queue using Python list.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "class CircularQueue:\n    def __init__(self, size):\n        self.queue = [None]*size\n        self.front = self.rear = -1\n\n    def enqueue(self, item):\n        pass\n\n    def dequeue(self):\n        pass",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "Enqueue: 10, 20, 30; Dequeue: 10"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "2faf2429-a9e2-4df6-bb75-24886f0b8a73",
                "type": "mcq",
                "content": "Deque allows insertion at:",
                "xp_reward": 10,
                "explanation": "Deque supports both front and rear insertion.",
                "choices": [
                  "Front only",
                  "Rear only",
                  "Both ends",
                  "None"
                ],
                "correct_choice_index": 2
              },
              {
                "card_id": "fb4d0729-664a-4d97-88c0-fee1fcdfd582",
                "type": "fill-in-blank",
                "content": "Circular queue connects the last element to the _____.",
                "xp_reward": 10,
                "explanation": "This forms a loop to reuse empty spaces.",
                "correct_answers": [
                  "front"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          },
          {
            "topic_id": "e609eebb-5ac6-4e41-bd30-51f840a5d970",
            "title": "Stack & Queue Advanced Problems",
            "content": "Apply stacks and queues to solve advanced problems: sliding window maximum, stock span, and monotonic stacks.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "357efd69-4c23-45e8-aa29-f1042950f65c",
                "type": "theory",
                "content": "Advanced stack and queue problems involve using auxiliary data structures for efficient solutions. Examples include sliding window maximum using deque, stock span problem using stack, and BFS traversal using queue.",
                "xp_reward": 15,
                "explanation": "Using proper stack/queue techniques reduces time complexity from O(n^2) to O(n) in many cases."
              },
              {
                "card_id": "8cc17810-2026-4817-8b5a-d84554cca6cf",
                "type": "code",
                "content": "Find the maximum in every sliding window of size k in an array using deque.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "from collections import deque\n\ndef sliding_window_max(nums, k):\n    # Return list of max in every window\n    pass",
                "test_cases": [
                  {
                    "input": "[1,3,-1,-3,5,3,6,7], k=3",
                    "expected_output": "[3,3,5,5,6,7]"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "440a1a68-bfdf-4298-a0ee-c9e30545f060",
                "type": "code",
                "content": "Solve stock span problem using a stack.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def stock_span(prices):\n    # Return span array\n    pass",
                "test_cases": [
                  {
                    "input": "[100,80,60,70,60,75,85]",
                    "expected_output": "[1,1,1,2,1,4,6]"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "58e0d152-b3a4-4bf6-a727-bb6cf39d43f7",
                "type": "mcq",
                "content": "Which data structure is used in BFS traversal of a graph?",
                "xp_reward": 10,
                "explanation": "Queue maintains the order of visiting nodes in BFS.",
                "choices": [
                  "Stack",
                  "Queue",
                  "Deque",
                  "Priority Queue"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "fd723173-8f16-4cc4-92fe-4855e2640dc9",
                "type": "fill-in-blank",
                "content": "Monotonic stack is used to maintain elements in _____ order.",
                "xp_reward": 10,
                "explanation": "It helps in solving problems like next greater element efficiently.",
                "correct_answers": [
                  "sorted"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          }
        ]
      },
      {
        "module_id": "4000d850-af65-47b7-8820-fa877702c6c8",
        "title": "Module 4: Trees",
        "order": 4,
        "topics": [
          {
            "topic_id": "a1eb98b2-2e15-4a93-9690-760b08779efe",
            "title": "Binary Trees: Basics and Implementation",
            "content": "Learn the fundamentals of binary trees, node structure, and basic operations like insertion and traversal.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "9c268ff6-e1a9-4645-88f8-1d3a4b067382",
                "type": "theory",
                "content": "A binary tree is a hierarchical data structure in which each node has at most two children: left and right. Binary trees are used in hierarchical data representation, expression parsing, and search operations. Common terms include root (topmost node), leaf (nodes with no children), height (longest path from root to leaf), and depth (distance from root).",
                "xp_reward": 15,
                "explanation": "Binary trees form the basis of more advanced trees like BSTs, AVL trees, and heaps."
              },
              {
                "card_id": "a4b2cb8b-5043-409d-8608-af2506cfda18",
                "type": "code",
                "content": "Implement a basic binary tree node and create a small tree with 3 nodes.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "class TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\n# Create root and children\nroot = TreeNode(10)\nroot.left = TreeNode(5)\nroot.right = TreeNode(15)",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "Tree created with root=10, left=5, right=15"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "7c00bb51-5cd7-4b61-9ad1-507071289e9a",
                "type": "mcq",
                "content": "A node with no children is called a?",
                "xp_reward": 10,
                "explanation": "Leaf nodes have no children.",
                "choices": [
                  "Root",
                  "Leaf",
                  "Parent",
                  "Sibling"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "08dc8a78-422e-49f3-9ced-6456f4539184",
                "type": "fill-in-blank",
                "content": "The topmost node of a binary tree is called the _____.",
                "xp_reward": 10,
                "explanation": "",
                "correct_answers": [
                  "root"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          },
          {
            "topic_id": "ddb9ce61-da2c-498e-9927-856fdb68992a",
            "title": "Binary Tree Traversals",
            "content": "Learn in-order, pre-order, post-order, and level-order traversal techniques.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "a600c7a8-f927-4fa9-8ca3-65a39ccc8b57",
                "type": "theory",
                "content": "Tree traversal means visiting all nodes of a tree in a specific order. In-order (left, root, right) is commonly used in BSTs to get sorted order. Pre-order (root, left, right) is used for copying trees, and post-order (left, right, root) is used for deleting trees. Level-order uses a queue to visit nodes level by level.",
                "xp_reward": 15,
                "explanation": "Traversal techniques are foundational for tree algorithms."
              },
              {
                "card_id": "e81051c2-777a-4540-876b-91fb2929fca2",
                "type": "code",
                "content": "Write recursive functions for in-order, pre-order, and post-order traversal.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def inorder(node):\n    if node:\n        pass\n\ndef preorder(node):\n    if node:\n        pass\n\ndef postorder(node):\n    if node:\n        pass",
                "test_cases": [
                  {
                    "input": "Tree with root=10, left=5, right=15",
                    "expected_output": "Inorder: 5 10 15, Preorder: 10 5 15, Postorder: 5 15 10"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "6f076e70-8a98-44d1-b21f-435ad2835208",
                "type": "code",
                "content": "Implement level-order traversal using a queue.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "from collections import deque\n\ndef level_order(root):\n    pass",
                "test_cases": [
                  {
                    "input": "Tree with root=10, left=5, right=15",
                    "expected_output": "[10, 5, 15]"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "dcd83d7d-66a8-48a4-9f25-6b9c62ce83c7",
                "type": "mcq",
                "content": "Which traversal of a BST gives sorted output?",
                "xp_reward": 10,
                "explanation": "In-order traversal of a BST produces nodes in ascending order.",
                "choices": [
                  "Pre-order",
                  "In-order",
                  "Post-order",
                  "Level-order"
                ],
                "correct_choice_index": 1
              }
            ]
          },
          {
            "topic_id": "adcc72ce-e348-4d4f-b70b-70f9b798d88e",
            "title": "Binary Search Trees (BST)",
            "content": "Learn BST properties and how to insert, search, and delete nodes efficiently.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "f54ac583-19f6-46b4-b274-1acb341e2038",
                "type": "theory",
                "content": "A Binary Search Tree (BST) is a binary tree where for each node, all nodes in the left subtree are smaller, and all nodes in the right subtree are larger. BSTs provide efficient searching, insertion, and deletion with average time complexity O(log n).",
                "xp_reward": 15,
                "explanation": "BSTs are widely used in databases, indexing, and dynamic sets."
              },
              {
                "card_id": "caa76889-b533-4c54-a0d0-47955238daad",
                "type": "code",
                "content": "Implement insertion in a BST.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def insert(root, val):\n    # Insert value into BST\n    pass",
                "test_cases": [
                  {
                    "input": "[10,5,15], insert 12",
                    "expected_output": "BST updated with 12"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "5cf3b252-0ebf-4c3d-9cb3-ca4d4a280b3d",
                "type": "code",
                "content": "Implement search in a BST.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def search(root, val):\n    # Return True if val exists\n    pass",
                "test_cases": [
                  {
                    "input": "[10,5,15], search 15",
                    "expected_output": "True"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "d5eff350-0006-4241-a0e0-08d8024946bb",
                "type": "mcq",
                "content": "What is the time complexity of searching in a balanced BST?",
                "xp_reward": 10,
                "explanation": "Balanced BST allows logarithmic search time.",
                "choices": [
                  "O(n)",
                  "O(log n)",
                  "O(n log n)",
                  "O(1)"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "c3aed7a4-c9a3-4ce2-add1-f5e91e474804",
                "type": "fill-in-blank",
                "content": "All nodes in the right subtree of a BST node are _____ than the node.",
                "xp_reward": 10,
                "explanation": "",
                "correct_answers": [
                  "greater"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          },
          {
            "topic_id": "73fa0ef3-8525-4642-aa96-8f77895e3aee",
            "title": "Advanced Tree Problems",
            "content": "Solve problems like Lowest Common Ancestor (LCA), diameter, and maximum path sum.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "16ecd8fa-9f8f-44c2-b227-690a44b9a405",
                "type": "theory",
                "content": "Advanced tree problems involve recursion and tree properties. LCA finds the lowest node common to two nodes. Diameter is the longest path between two nodes. Maximum path sum finds the largest sum along any path from leaf to leaf or root to leaf.",
                "xp_reward": 15,
                "explanation": "These problems test both understanding and recursion skills."
              },
              {
                "card_id": "49742d30-5d9a-4ea9-bc08-1fe20a30a6c5",
                "type": "code",
                "content": "Find LCA of two nodes in a BST.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def lca_bst(root, n1, n2):\n    # Return LCA node\n    pass",
                "test_cases": [
                  {
                    "input": "BST with 10,5,15,3,7,12,18; find LCA of 3 and 7",
                    "expected_output": "5"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "b8805f08-3699-49b3-8dd4-f22195a432f8",
                "type": "code",
                "content": "Calculate the diameter of a binary tree.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def diameter(root):\n    # Return longest path length\n    pass",
                "test_cases": [
                  {
                    "input": "Tree with root=10, left=5, right=15",
                    "expected_output": "2"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "0c6604b9-4eff-4eb7-895b-a3d097c23f9d",
                "type": "code",
                "content": "Find maximum path sum from root to leaf.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def max_path_sum(root):\n    # Return maximum sum\n    pass",
                "test_cases": [
                  {
                    "input": "Tree with root=10, left=5, right=15",
                    "expected_output": "25"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "36164625-0061-4c47-b522-c424a9b86034",
                "type": "mcq",
                "content": "Lowest Common Ancestor in a BST can be found using?",
                "xp_reward": 10,
                "explanation": "BST properties allow finding LCA efficiently.",
                "choices": [
                  "Stack",
                  "Queue",
                  "BST properties",
                  "Level-order traversal"
                ],
                "correct_choice_index": 2
              }
            ]
          }
        ]
      },
      {
        "module_id": "9ce31993-152c-48cd-a401-66d9ad79ed04",
        "title": "Module 5: Heaps & Priority Queues",
        "order": 5,
        "topics": [
          {
            "topic_id": "59eda5f6-5270-426d-9c47-ab9e549c89c6",
            "title": "Introduction to Heaps",
            "content": "Learn what heaps are, their properties, and common applications in algorithms and priority queues.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "6d7139a6-1723-4015-a962-0cb66c4a8a6e",
                "type": "theory",
                "content": "A heap is a complete binary tree where each node satisfies the heap property. In a max-heap, each parent node is greater than or equal to its children, while in a min-heap, each parent node is smaller than or equal to its children. Heaps are widely used for implementing priority queues, heap sort, and graph algorithms.",
                "xp_reward": 15,
                "explanation": "Heaps allow efficient extraction of the maximum or minimum element in O(log n) time."
              },
              {
                "card_id": "e122b951-934d-4f27-8e6d-cbf2979ab324",
                "type": "code",
                "content": "Implement a basic min-heap class with insertion operation.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "import heapq\n\nclass MinHeap:\n    def __init__(self):\n        self.heap = []\n    def insert(self, val):\n        # Insert value into heap\n        pass",
                "test_cases": [
                  {
                    "input": "[10, 5, 15]",
                    "expected_output": "[5, 10, 15]"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "30c56c0a-06ea-4ab1-b445-d7bc65cd8251",
                "type": "mcq",
                "content": "In a max-heap, the root node is always?",
                "xp_reward": 10,
                "explanation": "The root of a max-heap contains the maximum element.",
                "choices": [
                  "Minimum",
                  "Maximum",
                  "Average",
                  "Random"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "fd25cdfd-ef76-4cbf-a6a7-2f1e60b7de28",
                "type": "fill-in-blank",
                "content": "Heaps are typically implemented as _____ trees.",
                "xp_reward": 10,
                "explanation": "",
                "correct_answers": [
                  "complete binary"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          },
          {
            "topic_id": "75860a64-62b4-4e89-9488-c36d92f29bab",
            "title": "Heap Operations: Insertion, Extraction, and Heapify",
            "content": "Learn key heap operations: inserting elements, extracting min/max, and maintaining heap property using heapify.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "6340ba07-203b-425d-93a2-21531926b8ec",
                "type": "theory",
                "content": "Heap operations include insertion (adding a new element), extraction (removing min or max), and heapify (adjusting tree to maintain heap property). Insertion and extraction have O(log n) complexity, while building a heap using heapify can be done in O(n) time.",
                "xp_reward": 15,
                "explanation": "Understanding heap operations is crucial for implementing heap sort and priority queues."
              },
              {
                "card_id": "2e08d1fa-ae6c-4f42-9f15-25b1fc2cfb9a",
                "type": "code",
                "content": "Implement extraction of the minimum element from a min-heap.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def extract_min(self):\n    # Remove and return min element\n    pass",
                "test_cases": [
                  {
                    "input": "[5, 10, 15]",
                    "expected_output": "5"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "be51ed88-cffb-41f9-a1e9-3ab7b41880c5",
                "type": "code",
                "content": "Implement heapify function for a subtree rooted at index i.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def heapify(arr, n, i):\n    # Adjust subtree to maintain min-heap\n    pass",
                "test_cases": [
                  {
                    "input": "[3, 1, 6, 5, 2, 4], i=0",
                    "expected_output": "[1, 2, 4, 5, 3, 6]"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "b765bc5d-d850-40be-a69d-08b737fe313c",
                "type": "mcq",
                "content": "Time complexity of extracting the root from a heap is?",
                "xp_reward": 10,
                "explanation": "Extraction requires removing the root and reheapifying.",
                "choices": [
                  "O(n)",
                  "O(log n)",
                  "O(1)",
                  "O(n log n)"
                ],
                "correct_choice_index": 1
              }
            ]
          },
          {
            "topic_id": "3c5fae23-b5bd-42d0-a710-f3dc8d3ce350",
            "title": "Heap Sort",
            "content": "Learn heap sort algorithm and its implementation using heaps.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "9d2b2c12-a7b7-4931-98c8-072e0cc7d2a1",
                "type": "theory",
                "content": "Heap sort is a comparison-based sorting algorithm using a heap. Steps: 1) Build a max-heap from the array. 2) Swap the root with the last element. 3) Reduce heap size and heapify the root. Repeat until sorted. Time complexity: O(n log n) and space complexity: O(1).",
                "xp_reward": 15,
                "explanation": "Heap sort is efficient and avoids recursion overhead unlike quicksort."
              },
              {
                "card_id": "35042e5c-3ae8-4c7f-b479-3e40762c30ac",
                "type": "code",
                "content": "Implement heap sort using Python's heapq module.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "import heapq\n\ndef heap_sort(arr):\n    # Sort array using heap\n    pass",
                "test_cases": [
                  {
                    "input": "[4, 10, 3, 5, 1]",
                    "expected_output": "[1, 3, 4, 5, 10]"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "c8608b17-2d9c-4a06-b368-04f9e85c508a",
                "type": "mcq",
                "content": "Heap sort is a _____ sorting algorithm.",
                "xp_reward": 10,
                "explanation": "Heap sort is in-place but not stable.",
                "choices": [
                  "Stable",
                  "Unstable",
                  "In-place",
                  "Both B and C"
                ],
                "correct_choice_index": 3
              },
              {
                "card_id": "aff8d3f5-25c6-4da0-80e8-1162264daf1a",
                "type": "fill-in-blank",
                "content": "Building a heap from an array can be done in _____ time complexity.",
                "xp_reward": 10,
                "explanation": "",
                "correct_answers": [
                  "O(n)"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          },
          {
            "topic_id": "476dd44c-6dd0-4ca1-81f2-bb007b4faf5a",
            "title": "Priority Queues",
            "content": "Implement priority queues using heaps and solve real-world problems.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "d040a732-d078-45a1-b4cd-35c963b2f391",
                "type": "theory",
                "content": "A priority queue is an abstract data type where each element has a priority. Elements with higher priority are dequeued before lower priority ones. Heaps provide an efficient way to implement priority queues, supporting insertion and extraction in O(log n) time.",
                "xp_reward": 15,
                "explanation": "Priority queues are used in task scheduling, Dijkstra's algorithm, and event simulation."
              },
              {
                "card_id": "c791080e-3508-4386-a99b-a77d63c4c82b",
                "type": "code",
                "content": "Implement a priority queue using a min-heap.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "import heapq\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heap = []\n    def push(self, val):\n        pass\n    def pop(self):\n        pass",
                "test_cases": [
                  {
                    "input": "[10,5,15]",
                    "expected_output": "[5,10,15]"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "0d7eb675-2b70-4ea4-b5d7-312b4f030143",
                "type": "code",
                "content": "Solve the 'K largest elements' problem using a heap.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def k_largest(arr, k):\n    # Return k largest elements\n    pass",
                "test_cases": [
                  {
                    "input": "[3,2,1,5,6,4], k=2",
                    "expected_output": "[6,5]"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "74920e59-8722-444c-bd99-7105724606c7",
                "type": "mcq",
                "content": "Which data structure is most efficient for implementing a priority queue?",
                "xp_reward": 10,
                "explanation": "Heap allows O(log n) insertion and extraction.",
                "choices": [
                  "Array",
                  "Linked List",
                  "Heap",
                  "Stack"
                ],
                "correct_choice_index": 2
              }
            ]
          }
        ]
      },
      {
        "module_id": "e28a05b5-688b-4f0a-9400-2192fa856d28",
        "title": "Module 6: Graphs & Graph Algorithms",
        "order": 6,
        "topics": [
          {
            "topic_id": "6ea4c19f-8d58-4fbd-907c-79d5c9f3bfaa",
            "title": "Introduction to Graphs",
            "content": "Understand graph fundamentals, types of graphs, and their representations.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "98b72a38-fe2b-4e31-9a6b-88579f8c0ff4",
                "type": "theory",
                "content": "A graph is a collection of nodes (vertices) connected by edges. Graphs can be directed or undirected, weighted or unweighted. Common representations include adjacency lists and adjacency matrices. Graphs are used in networking, social networks, pathfinding, and scheduling problems.",
                "xp_reward": 15,
                "explanation": "Graph representation affects memory usage and algorithm efficiency."
              },
              {
                "card_id": "8f53db79-c540-4178-80d3-b3979602f84a",
                "type": "mcq",
                "content": "Which graph representation is memory-efficient for sparse graphs?",
                "xp_reward": 10,
                "explanation": "Adjacency lists only store existing edges, saving memory.",
                "choices": [
                  "Adjacency Matrix",
                  "Adjacency List",
                  "Edge List",
                  "Incidence Matrix"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "59b4e441-fb56-4db7-ab1e-e1110574bbb8",
                "type": "fill-in-blank",
                "content": "A graph in which edges have directions is called a _____ graph.",
                "xp_reward": 10,
                "explanation": "",
                "correct_answers": [
                  "directed"
                ],
                "blanks": [
                  "blank"
                ]
              },
              {
                "card_id": "4addeae4-4ec3-4064-818b-09daf3710c69",
                "type": "code",
                "content": "Create a simple undirected graph using an adjacency list.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "graph = {}\n\n# Add edges between nodes\ngraph['A'] = ['B', 'C']\ngraph['B'] = ['A', 'D']\ngraph['C'] = ['A']\ngraph['D'] = ['B']",
                "test_cases": [
                  {
                    "input": "",
                    "expected_output": "{'A': ['B','C'], 'B': ['A','D'], 'C':['A'], 'D':['B']}"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          },
          {
            "topic_id": "4e4ff5fa-f534-4499-8be2-15111f10549f",
            "title": "Breadth-First Search (BFS)",
            "content": "Learn BFS traversal of graphs using a queue.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "f2d99b5e-69cc-4bdc-9d91-312d84958ec3",
                "type": "theory",
                "content": "Breadth-First Search (BFS) visits all vertices level by level starting from a source node. It uses a queue to track the next vertex to visit and a set or array to mark visited vertices. BFS is used for shortest path in unweighted graphs and graph connectivity.",
                "xp_reward": 15,
                "explanation": "BFS ensures that nodes closer to the source are visited before nodes farther away."
              },
              {
                "card_id": "cd51cb8a-7b79-43f8-a749-219f5fe6be14",
                "type": "code",
                "content": "Implement BFS traversal of a graph starting from a given node.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "from collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    while queue:\n        node = queue.popleft()\n        pass",
                "test_cases": [
                  {
                    "input": "graph, start='A'",
                    "expected_output": "['A','B','C','D']"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "6db395af-7db3-400e-bcac-5599e68ee152",
                "type": "mcq",
                "content": "Which data structure is used to implement BFS?",
                "xp_reward": 10,
                "explanation": "Queue ensures FIFO order for BFS.",
                "choices": [
                  "Stack",
                  "Queue",
                  "Heap",
                  "Priority Queue"
                ],
                "correct_choice_index": 1
              }
            ]
          },
          {
            "topic_id": "11a7895e-f7e9-4aa0-a902-cda5ad309822",
            "title": "Depth-First Search (DFS)",
            "content": "Learn DFS traversal using recursion or stack.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "415c9baf-5915-415c-97c3-7f13c10a559a",
                "type": "theory",
                "content": "Depth-First Search (DFS) explores as far as possible along each branch before backtracking. DFS can be implemented using recursion or an explicit stack. DFS is useful for cycle detection, topological sorting, and pathfinding in graphs.",
                "xp_reward": 15,
                "explanation": "DFS explores nodes deeply before exploring neighbors."
              },
              {
                "card_id": "96dcf88e-4ce1-471d-bfe8-bc6cd1b60d3a",
                "type": "code",
                "content": "Implement recursive DFS traversal of a graph.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def dfs(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    pass",
                "test_cases": [
                  {
                    "input": "graph, start='A'",
                    "expected_output": "['A','B','D','C']"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "a3749146-93d5-4ac2-9fa5-1394ef631e02",
                "type": "fill-in-blank",
                "content": "DFS can be implemented using recursion or an explicit _____ data structure.",
                "xp_reward": 10,
                "explanation": "",
                "correct_answers": [
                  "stack"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          },
          {
            "topic_id": "4f2bcbc8-5384-4a23-91bd-032942515163",
            "title": "Shortest Path Algorithms",
            "content": "Learn Dijkstra's algorithm for weighted graphs and Bellman-Ford for graphs with negative weights.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "fb04f2e4-b09c-4987-979e-cc144b2fa50a",
                "type": "theory",
                "content": "Dijkstra's algorithm finds the shortest path from a source to all other vertices in a weighted graph with non-negative edges. Bellman-Ford handles negative weight edges and can detect negative cycles. Both algorithms maintain a distance array and update distances iteratively.",
                "xp_reward": 15,
                "explanation": "Shortest path algorithms are essential for routing and network optimization."
              },
              {
                "card_id": "b9f37d63-4a50-458a-9e11-71850f368947",
                "type": "code",
                "content": "Implement Dijkstra's algorithm using a min-heap (priority queue).",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "import heapq\n\ndef dijkstra(graph, start):\n    # Return distance from start to all nodes\n    pass",
                "test_cases": [
                  {
                    "input": "graph, start='A'",
                    "expected_output": "{'A':0,'B':1,'C':4,'D':2}"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "896a9ddf-4630-4c7d-9fe1-ac255df093bf",
                "type": "mcq",
                "content": "Which algorithm detects negative cycles in a graph?",
                "xp_reward": 10,
                "explanation": "Bellman-Ford can detect negative weight cycles.",
                "choices": [
                  "Dijkstra",
                  "Bellman-Ford",
                  "Floyd-Warshall",
                  "Prim"
                ],
                "correct_choice_index": 1
              }
            ]
          },
          {
            "topic_id": "37cb8675-1376-40b1-9456-9b26c3cc446d",
            "title": "Advanced Graph Problems",
            "content": "Learn topological sort, connected components, and cycle detection.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "e72c439c-5ece-4738-bece-ca45819df8ee",
                "type": "theory",
                "content": "Topological sorting orders vertices in a Directed Acyclic Graph (DAG) such that for every directed edge u→v, u comes before v. Connected components identify subgraphs where every node is reachable from any other. Cycle detection checks for loops in graphs, crucial for scheduling and dependency problems.",
                "xp_reward": 15,
                "explanation": "These problems are common in competitive programming and real-world applications."
              },
              {
                "card_id": "58e8071a-c648-4173-81f5-82b835021ee5",
                "type": "code",
                "content": "Implement topological sort using DFS.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def topo_sort(graph):\n    visited = set()\n    stack = []\n    pass",
                "test_cases": [
                  {
                    "input": "DAG graph",
                    "expected_output": "['A','B','C','D']"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "4b6224ef-b187-4bfc-8fbe-e08c2ce48149",
                "type": "code",
                "content": "Detect cycles in a directed graph using DFS.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def has_cycle(graph):\n    visited = set()\n    rec_stack = set()\n    pass",
                "test_cases": [
                  {
                    "input": "graph with cycle",
                    "expected_output": "True"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "934208e2-12ed-4627-98b4-4d91db88ff5b",
                "type": "mcq",
                "content": "Topological sort can be applied to which type of graph?",
                "xp_reward": 10,
                "explanation": "Topological sort is only possible for DAGs.",
                "choices": [
                  "Undirected",
                  "Directed Graph with cycles",
                  "Directed Acyclic Graph",
                  "Weighted Graph only"
                ],
                "correct_choice_index": 2
              }
            ]
          }
        ]
      },
      {
        "module_id": "0a483aae-2127-43f7-aa52-78b91b3ec40f",
        "title": "Module 7: Recursion & Backtracking",
        "order": 7,
        "topics": [
          {
            "topic_id": "30b0e9c8-9b03-4cdb-98ec-2cceb2126c85",
            "title": "Introduction to Recursion",
            "content": "Learn the fundamentals of recursion, base cases, and recursive calls.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "0042e5d7-e6e2-499d-8869-786f99f636be",
                "type": "theory",
                "content": "Recursion is a technique where a function calls itself to solve smaller instances of the same problem. Each recursive function must have a base case to stop recursion. Common examples include factorial, Fibonacci sequence, and sum of elements in a list.",
                "xp_reward": 15,
                "explanation": "Understanding recursion is essential for divide-and-conquer algorithms and backtracking."
              },
              {
                "card_id": "dfcbd642-e9ba-4c81-bba1-bb2523cdea02",
                "type": "code",
                "content": "Write a recursive function to compute factorial of a number n.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def factorial(n):\n    # Return n!\n    pass",
                "test_cases": [
                  {
                    "input": "5",
                    "expected_output": "120"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "0345d950-5764-4440-bbb9-14aad27eeb76",
                "type": "mcq",
                "content": "What is required to prevent infinite recursion?",
                "xp_reward": 10,
                "explanation": "A base case ensures recursion stops.",
                "choices": [
                  "Loop",
                  "Stack",
                  "Base case",
                  "Return statement only"
                ],
                "correct_choice_index": 2
              },
              {
                "card_id": "d2550474-7cb2-48d5-a7d8-16f3450523a0",
                "type": "fill-in-blank",
                "content": "Recursion that calls itself with smaller input and reaches a stopping condition is called _____ recursion.",
                "xp_reward": 10,
                "explanation": "",
                "correct_answers": [
                  "direct"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          },
          {
            "topic_id": "7ecbef0f-b99a-4c05-8324-c441d2c19693",
            "title": "Recursive Problem Patterns",
            "content": "Learn common recursive patterns like divide-and-conquer and backtracking templates.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "b24aae58-53f8-4f5b-a7c4-d5324e70b5b4",
                "type": "theory",
                "content": "Divide-and-conquer recursion splits the problem into subproblems, solves each recursively, and combines results. Examples: Merge Sort, Quick Sort. Backtracking recursion explores all possible choices and abandons paths that violate constraints, used in puzzles and combinatorial problems.",
                "xp_reward": 15,
                "explanation": "Recognizing patterns helps write efficient recursive solutions."
              },
              {
                "card_id": "651ef6ce-160e-4879-ae47-8138e0dbc6e2",
                "type": "code",
                "content": "Implement recursive binary search on a sorted array.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def binary_search(arr, target, low, high):\n    # Return index of target or -1\n    pass",
                "test_cases": [
                  {
                    "input": "[1,3,5,7], target=5",
                    "expected_output": "2"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "9fb17399-cf68-48fd-9218-ee186387c7b1",
                "type": "code",
                "content": "Compute nth Fibonacci number using recursion.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def fibonacci(n):\n    # Return nth Fibonacci number\n    pass",
                "test_cases": [
                  {
                    "input": "7",
                    "expected_output": "13"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          },
          {
            "topic_id": "b8bfac73-8668-4927-ac0b-f39d26fa9a6a",
            "title": "Backtracking Basics",
            "content": "Learn the fundamentals of backtracking and solving combinatorial problems.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "e5f6e006-16fa-4000-9915-9b5dabd0a588",
                "type": "theory",
                "content": "Backtracking is a recursive algorithmic technique for solving problems incrementally, trying partial solutions and abandoning them if they do not lead to a valid solution. Typical examples include N-Queens, Sudoku Solver, and generating permutations.",
                "xp_reward": 15,
                "explanation": "Backtracking is used to explore all potential solution paths efficiently."
              },
              {
                "card_id": "1fdd5c9f-e781-4340-b145-d3010610029a",
                "type": "code",
                "content": "Implement a recursive function to generate all permutations of a list.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def permute(nums):\n    # Return list of permutations\n    pass",
                "test_cases": [
                  {
                    "input": "[1,2,3]",
                    "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "322d437b-7346-43a9-8029-9f74c58b836f",
                "type": "mcq",
                "content": "Backtracking is primarily used for which type of problems?",
                "xp_reward": 10,
                "explanation": "Backtracking explores all possible solutions in combinatorial problems.",
                "choices": [
                  "Sorting",
                  "Combinatorial",
                  "Searching in sorted array",
                  "Graph BFS only"
                ],
                "correct_choice_index": 1
              }
            ]
          },
          {
            "topic_id": "b0d9c363-b59c-4e99-8193-5fe7ca202ce2",
            "title": "N-Queens Problem",
            "content": "Solve the N-Queens problem using backtracking.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "0db1654c-169a-469d-a9c5-eb04ecb23170",
                "type": "theory",
                "content": "The N-Queens problem places N queens on an N×N chessboard such that no two queens attack each other. A backtracking approach places queens row by row and backtracks when a conflict is detected.",
                "xp_reward": 15,
                "explanation": "This classic problem illustrates the power of recursive backtracking."
              },
              {
                "card_id": "937ebe91-ff53-458e-b274-3c33220e4ba6",
                "type": "code",
                "content": "Implement N-Queens solver for a given N and return all solutions.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def solve_n_queens(n):\n    # Return list of board configurations\n    pass",
                "test_cases": [
                  {
                    "input": "4",
                    "expected_output": "[['.Q..','...Q','Q...','..Q.'], ['..Q.','Q...','...Q','.Q..']]"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "2df82b9a-b8a0-4add-9e3b-4b813c05a929",
                "type": "fill-in-blank",
                "content": "In N-Queens problem, each queen must be placed such that it does not share the same _____ with another queen.",
                "xp_reward": 10,
                "explanation": "",
                "correct_answers": [
                  "row, column, or diagonal"
                ],
                "blanks": [
                  "blank"
                ]
              }
            ]
          },
          {
            "topic_id": "7abecb23-44e9-4958-a2c4-d2af9aaae2b6",
            "title": "Sudoku Solver",
            "content": "Use backtracking to solve a Sudoku puzzle.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "5255c83d-76ed-486f-957d-f161d3ea6e8c",
                "type": "theory",
                "content": "Sudoku is a 9×9 grid where each row, column, and 3×3 subgrid must contain numbers 1 to 9 exactly once. Backtracking tries numbers in empty cells and recurses. If a conflict occurs, it backtracks to try a different number.",
                "xp_reward": 15,
                "explanation": "Backtracking efficiently explores valid Sudoku configurations."
              },
              {
                "card_id": "0b9a5ce7-b166-49d4-9dc8-e8f0173b401d",
                "type": "code",
                "content": "Implement a Sudoku solver using backtracking.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def solve_sudoku(board):\n    # Modify board to solve Sudoku\n    pass",
                "test_cases": [
                  {
                    "input": "[[5,3,0,0,...]],",
                    "expected_output": "[[5,3,4,6,...]]"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "9086587d-0e70-429b-b533-53fb5a7fd15e",
                "type": "mcq",
                "content": "Which algorithmic technique is used in Sudoku solving?",
                "xp_reward": 10,
                "explanation": "Backtracking explores all number placements and abandons invalid paths.",
                "choices": [
                  "Dynamic Programming",
                  "Backtracking",
                  "Greedy",
                  "BFS"
                ],
                "correct_choice_index": 1
              }
            ]
          },
          {
            "topic_id": "e6ed868f-be95-4b72-af11-f8af5f952bbe",
            "title": "Advanced Backtracking Patterns",
            "content": "Learn general patterns for permutations, combinations, and subset generation.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "a24f8113-a44d-4a7e-a7e3-c6dbc565403a",
                "type": "theory",
                "content": "Backtracking problems often follow patterns: (1) choose an option, (2) recurse, (3) undo choice (backtrack). This pattern applies to generating all subsets, combinations of k elements, or sequences with constraints.",
                "xp_reward": 15,
                "explanation": "Recognizing these patterns makes solving combinatorial problems faster and cleaner."
              },
              {
                "card_id": "a8215bee-cd03-4299-a8e2-2591ba325820",
                "type": "code",
                "content": "Generate all subsets of a list using backtracking.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def subsets(nums):\n    # Return all subsets\n    pass",
                "test_cases": [
                  {
                    "input": "[1,2,3]",
                    "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "1229bd9f-3a1c-4e77-93e9-b4ea0f9840eb",
                "type": "code",
                "content": "Generate all combinations of k elements from a list.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def combine(nums, k):\n    # Return list of combinations\n    pass",
                "test_cases": [
                  {
                    "input": "[1,2,3,4], k=2",
                    "expected_output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          }
        ]
      },
      {
        "module_id": "3e816b21-5ea4-4b1d-a2b0-120fafd0c428",
        "title": "Module 8: Dynamic Programming",
        "order": 8,
        "topics": [
          {
            "topic_id": "28c99f08-ccec-4fcd-8d1f-db3ed7c5c877",
            "title": "Introduction to Dynamic Programming",
            "content": "Understand the concept of DP, overlapping subproblems, and optimal substructure.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "8ef7a524-5ecc-4082-9407-e080e4736c52",
                "type": "theory",
                "content": "Dynamic Programming (DP) is an optimization technique to solve problems by breaking them into overlapping subproblems and storing the results to avoid recomputation. It is based on two properties: overlapping subproblems and optimal substructure. Common examples include Fibonacci, Knapsack, and Longest Common Subsequence (LCS).",
                "xp_reward": 15,
                "explanation": "Recognizing DP patterns allows solving complex problems efficiently."
              },
              {
                "card_id": "94238fbc-1620-4333-a1a7-5f8089ed9947",
                "type": "mcq",
                "content": "What are the two key properties of DP?",
                "xp_reward": 10,
                "explanation": "",
                "choices": [
                  "Greedy choice and recursion",
                  "Overlapping subproblems and optimal substructure",
                  "Backtracking and recursion",
                  "Divide and conquer and recursion"
                ],
                "correct_choice_index": 1
              },
              {
                "card_id": "45c11092-6c06-4fcf-a35d-0e83c2b4a3ae",
                "type": "code",
                "content": "Compute nth Fibonacci number using DP (memoization).",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def fibonacci(n, memo={}):\n    # Return nth Fibonacci number\n    pass",
                "test_cases": [
                  {
                    "input": "7",
                    "expected_output": "13"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          },
          {
            "topic_id": "fb185d56-9129-46ca-81c4-50b1db254825",
            "title": "Memoization Technique",
            "content": "Learn top-down DP using recursion with memoization.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "d9b8b20c-6c6e-4062-9cf2-2734a2711a4a",
                "type": "theory",
                "content": "Memoization is a top-down DP approach where results of recursive calls are cached. This prevents recomputation of overlapping subproblems, drastically reducing time complexity.",
                "xp_reward": 15,
                "explanation": "Memoization is especially useful in recursive solutions like Fibonacci, Grid Paths, and Knapsack."
              },
              {
                "card_id": "800ae63d-f080-4cb8-910a-e53f7836033f",
                "type": "code",
                "content": "Solve 0/1 Knapsack problem using recursion with memoization.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def knapsack(weights, values, n, W, memo={}):\n    # Return maximum value\n    pass",
                "test_cases": [
                  {
                    "input": "[1,2,3], [10,20,30], n=3, W=5",
                    "expected_output": "50"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          },
          {
            "topic_id": "23c22821-aa84-4f03-a834-2579ee2a845b",
            "title": "Tabulation Technique",
            "content": "Learn bottom-up DP approach using tabulation.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "c4d47ee7-8353-4d52-8f01-1568e4e71e47",
                "type": "theory",
                "content": "Tabulation is a bottom-up DP approach that fills a table iteratively based on smaller subproblems. Unlike memoization, it does not use recursion. This approach often reduces stack usage and simplifies debugging.",
                "xp_reward": 15,
                "explanation": "Tabulation is widely used in problems like LCS, DP on grids, and coin change."
              },
              {
                "card_id": "3357cdc2-145f-458c-b83a-1177a693fc81",
                "type": "code",
                "content": "Implement Fibonacci using bottom-up tabulation.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def fibonacci_tab(n):\n    # Return nth Fibonacci number\n    pass",
                "test_cases": [
                  {
                    "input": "7",
                    "expected_output": "13"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          },
          {
            "topic_id": "9dcec9c1-cb7e-43f6-9f5f-99b2daa3f159",
            "title": "0/1 Knapsack Problem",
            "content": "Classic DP problem to maximize value under weight constraints.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "9c83d6dd-f995-4535-8e36-8473347e7fb8",
                "type": "theory",
                "content": "In the 0/1 Knapsack problem, each item can be picked at most once. The goal is to maximize the total value without exceeding weight capacity. Use DP by building a table dp[i][w] representing maximum value using first i items with weight limit w.",
                "xp_reward": 15,
                "explanation": "0/1 Knapsack is a cornerstone DP problem used in optimization."
              },
              {
                "card_id": "5127fcc2-ff2f-4b9e-8e3a-7d0fec88d2b4",
                "type": "code",
                "content": "Solve 0/1 Knapsack using tabulation.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def knapsack_tab(weights, values, W):\n    # Return maximum value\n    pass",
                "test_cases": [
                  {
                    "input": "[1,2,3], [10,20,30], W=5",
                    "expected_output": "50"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          },
          {
            "topic_id": "c2a098e5-2437-4d44-8b1b-708cc8c6c839",
            "title": "Unbounded Knapsack",
            "content": "Knapsack problem where each item can be picked multiple times.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "555422bc-8b78-4a51-a6ae-fef0b1739d95",
                "type": "theory",
                "content": "Unbounded Knapsack allows unlimited copies of each item. DP table dp[w] stores maximum value for weight w. Update dp[w] by iterating over all items and taking max(dp[w], dp[w-item_weight]+item_value).",
                "xp_reward": 15,
                "explanation": "Unbounded Knapsack models problems like rod cutting and coin change."
              },
              {
                "card_id": "0ef8e922-7f16-48ce-8e02-2ff6c59b6c18",
                "type": "code",
                "content": "Solve Unbounded Knapsack using DP.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def unbounded_knapsack(weights, values, W):\n    # Return maximum value\n    pass",
                "test_cases": [
                  {
                    "input": "[1,2,3], [10,20,30], W=5",
                    "expected_output": "60"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          },
          {
            "topic_id": "62b2cf69-d271-47b8-9009-266f17b644f7",
            "title": "Longest Common Subsequence (LCS)",
            "content": "Find the longest subsequence common to two strings.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "6479b2db-1001-4d27-85b1-f5dddd5a3ca2",
                "type": "theory",
                "content": "The LCS problem finds the maximum length subsequence common to two sequences. DP approach uses a table dp[i][j] where dp[i][j] stores LCS length for first i characters of string A and first j characters of string B.",
                "xp_reward": 15,
                "explanation": "LCS is fundamental in text comparison and sequence alignment."
              },
              {
                "card_id": "64c5b4c8-05b4-40cf-af3f-3558bd3c2c56",
                "type": "code",
                "content": "Compute LCS of two strings using DP.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def lcs(X, Y):\n    # Return length of LCS\n    pass",
                "test_cases": [
                  {
                    "input": "X='AGGTAB', Y='GXTXAYB'",
                    "expected_output": "4"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          },
          {
            "topic_id": "9d91c76a-0e16-4e23-a74a-cb24d7ff8131",
            "title": "Minimum Path Sum (Grid DP)",
            "content": "DP on 2D grids to find minimum cost path.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "05e9af55-b5d5-4610-a088-b966f36ac6d5",
                "type": "theory",
                "content": "Given a grid with non-negative costs, find path from top-left to bottom-right with minimum sum. DP formula: dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]).",
                "xp_reward": 15,
                "explanation": "Grid DP is essential for robotics, pathfinding, and game AI problems."
              },
              {
                "card_id": "529082c3-9066-4c13-a131-271c3da6988a",
                "type": "code",
                "content": "Compute minimum path sum in a grid using DP.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def min_path_sum(grid):\n    # Return minimum path sum\n    pass",
                "test_cases": [
                  {
                    "input": "[[1,3,1],[1,5,1],[4,2,1]]",
                    "expected_output": "7"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          },
          {
            "topic_id": "cd54cd3c-d96d-4463-90d3-b083a36874db",
            "title": "Advanced DP Patterns",
            "content": "Learn patterns for DP on subsequences, partitions, and combinatorial counts.",
            "xp_reward": 150,
            "cards": [
              {
                "card_id": "d777d380-5cbf-4dd9-8fbd-93493f5545db",
                "type": "theory",
                "content": "DP problems often follow patterns: (1) subsequence/subset DP (e.g., LCS, LIS), (2) partition DP (e.g., integer partition, palindrome partitioning), (3) combinatorial DP (e.g., coin change, ways to climb stairs). Recognizing patterns is key to solving new DP problems quickly.",
                "xp_reward": 15,
                "explanation": "Practice multiple DP patterns to build intuition and improve problem-solving speed."
              },
              {
                "card_id": "594da12a-1d4e-47ae-8b71-985bd6c8aec8",
                "type": "code",
                "content": "Compute number of ways to climb n stairs taking 1 or 2 steps each time.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def climb_stairs(n):\n    # Return number of ways\n    pass",
                "test_cases": [
                  {
                    "input": "4",
                    "expected_output": "5"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              },
              {
                "card_id": "9736ed14-1b92-45ed-be0e-2120626f36ec",
                "type": "code",
                "content": "Compute minimum number of coins for given amount using given denominations.",
                "xp_reward": 25,
                "explanation": "",
                "starter_code": "def coin_change(coins, amount):\n    # Return minimum number of coins\n    pass",
                "test_cases": [
                  {
                    "input": "coins=[1,2,5], amount=11",
                    "expected_output": "3"
                  }
                ],
                "is_practice_problem": false,
                "difficulty": "Medium",
                "tags": []
              }
            ]
          }
        ]
      }
    ]
  }
]